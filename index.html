<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Niagara Sidekick - Point Explorer</title>
    <style>
        :root {
            /* Figma Dark Theme - oklch converted to hex */
            --background-color: #242424;  /* oklch(.145 0 0) - Main background */
            --surface-color: #242424;     /* Card/surface color */
            --sidebar-color: #343434;     /* oklch(.205 0 0) - Sidebar slightly lighter */
            --accent-color: #4db864;      /* Primary accent green */
            --success-color: #10b981;     /* Green for success states */
            --warning-color: #f59e0b;     /* Orange for warnings */
            --error-color: #ef4444;       /* Red for errors */

            --text-primary: #fafafa;      /* oklch(.985 0 0) - Primary text */
            --text-secondary: #cbd5e1;    /* Secondary text */
            --text-muted: #a1a1a1;        /* oklch(.708 0 0) - Muted text */

            --border-color: #3a3a3a;      /* oklch(.269 0 0) - Borders */
            --hover-color: #2f2f2f;       /* Hover state */

            --primary-color: #fafafa;     /* For light elements */
            --secondary-color: #3a3a3a;   /* Secondary elements */

            --shadow-light: 0 1px 2px 0 rgb(0 0 0 / 0.5);
            --shadow-medium: 0 4px 6px -1px rgb(0 0 0 / 0.6);
            --shadow-heavy: 0 10px 15px -3px rgb(0 0 0 / 0.7);
            --radius-small: 0.375rem;
            --radius-medium: 0.5rem;
            --radius-large: 0.75rem;
            --transition: all 0.15s ease;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Inter', 'Segoe UI', 'Roboto', sans-serif;
            background: var(--background-color);
            color: var(--text-primary);
            font-size: 14px;
            line-height: 1.5;
            overflow: hidden;
            font-weight: 400;
        }
        
        .app {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        .header {
            background: var(--background-color);
            color: var(--text-primary);
            height: 56px;
            padding: 0 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
        }

        .header h1 {
            font-size: 15px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .header-center {
            flex: 1;
            max-width: 400px;
            margin: 0 24px;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .logo {
            padding: 5px 16px;
            background: var(--text-primary);
            color: var(--background-color);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 18px;
            letter-spacing: -1px;
            white-space: nowrap;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .logo-img {
            height: 32px;
            width: auto;
            color: var(--primary-color);
        }

        .header-separator {
            height: 24px;
            width: 1px;
            background: var(--border-color);
        }

        .search-bar {
            position: relative;
            width: 100%;
        }

        .search-bar input {
            width: 100%;
            padding: 8px 12px 8px 36px;
            background: var(--sidebar-color);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-small);
            color: var(--text-primary);
            font-size: 13px;
            outline: none;
            transition: var(--transition);
        }

        .search-bar input:focus {
            border-color: var(--accent-color);
            background: var(--surface-color);
        }

        .search-bar input::placeholder {
            color: var(--text-muted);
        }

        .search-bar i {
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-muted);
            width: 16px;
            height: 16px;
        }

        .icon-button {
            width: 32px;
            height: 32px;
            padding: 0;
            background: transparent;
            border: none;
            border-radius: var(--radius-small);
            color: var(--text-muted);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: var(--transition);
        }

        .icon-button:hover {
            background: var(--hover-color);
            color: var(--text-primary);
        }

        .icon-button i {
            width: 18px;
            height: 18px;
        }

        .status-badge {
            padding: 4px 10px;
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid rgba(16, 185, 129, 0.2);
            border-radius: var(--radius-small);
            color: var(--success-color);
            font-size: 12px;
            font-weight: 500;
        }

        .header-info {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 4px;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .nav-buttons {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .nav-button {
            padding: 8px 16px;
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-small);
            color: var(--text-secondary);
            text-decoration: none;
            font-size: 12px;
            font-weight: 500;
            transition: var(--transition);
            cursor: pointer;
        }

        .nav-button:hover {
            background: var(--background-color);
            border-color: var(--text-muted);
            color: var(--text-primary);
        }

        .nav-button.active {
            background: var(--accent-color);
            border-color: var(--accent-color);
            color: white;
            font-weight: 600;
        }

        .clear-button {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-small);
            color: var(--error-color);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
            text-decoration: none;
        }

        .clear-button:hover {
            background: #450a0a;
            border-color: var(--error-color);
        }

        .clear-button svg {
            width: 18px;
            height: 18px;
        }

        .header-status {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--success-color);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .toolbar {
            background: var(--surface-color);
            padding: 16px 24px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            gap: 12px;
            box-shadow: var(--shadow-light);
        }

        .btn {
            padding: 10px 16px;
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            border-radius: var(--radius-small);
            color: var(--text-primary);
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }

        .btn:hover {
            background: var(--background-color);
            border-color: var(--text-muted);
        }

        .btn.active {
            background: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
            box-shadow: var(--shadow-light);
        }

        .btn.primary {
            background: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
            font-weight: 600;
        }

        .btn.primary:hover {
            background: #2563eb;
            border-color: #2563eb;
        }

        /* Two-level tab structure */
        .toolbar {
            flex-direction: column;
            gap: 0;
        }

        .main-tabs {
            display: flex;
            gap: 8px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border-color);
        }

        .main-tab {
            padding: 12px 20px;
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            border-bottom: none;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            border-radius: var(--radius-small) var(--radius-small) 0 0;
            color: var(--text-secondary);
            transition: var(--transition);
            white-space: nowrap;
        }

        .main-tab:hover {
            background: var(--background-color);
            color: var(--text-primary);
        }

        .main-tab.active {
            background: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
            transform: translateY(1px);
        }

        /* Header tabs (moved from toolbar) */
        .header-tab {
            padding: 8px 16px;
            background: transparent;
            border: none;
            cursor: pointer;
            border-radius: var(--radius-small);
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            font-weight: 500;
            color: var(--text-secondary);
            transition: var(--transition);
            white-space: nowrap;
        }

        .header-tab:hover {
            background: var(--hover-color);
            color: var(--text-primary);
        }

        .header-tab.active {
            background: var(--accent-color);
            color: white;
        }

        .sub-tabs-container {
            display: none;
            padding-top: 12px;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
        }

        .sub-tabs-container.active {
            display: flex;
        }

        .sub-tabs {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .sub-tab {
            padding: 8px 14px;
            background: var(--background-color);
            border: 1px solid var(--border-color);
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            border-radius: var(--radius-small);
            color: var(--text-secondary);
            transition: var(--transition);
            white-space: nowrap;
        }

        .sub-tab:hover {
            background: var(--secondary-color);
            color: var(--text-primary);
        }

        .sub-tab.active {
            background: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
        }

        .tree-controls {
            display: none;
            gap: 6px;
            margin-left: auto;
        }

        .tree-controls.active {
            display: flex;
        }

        .tree-controls .btn {
            padding: 6px 12px;
            font-size: 12px;
        }

        .main {
            flex: 1;
            display: flex;
            overflow: hidden;
        }
        
        .sidebar {
            width: 256px;
            background: var(--sidebar-color);
            border-right: 1px solid var(--border-color);
            padding: 16px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .content {
            flex: 1;
            background: var(--background-color);
            overflow-y: auto;
        }
        
        .detail-panel {
            width: 420px;
            background: var(--surface-color);
            border-left: 1px solid var(--border-color);
            padding: 0;
            overflow-y: auto;
            display: none;
            box-shadow: var(--shadow-medium);
            transform: translateX(100%);
            transition: transform 0.3s ease;
        }

        .detail-panel.show {
            display: block;
            transform: translateX(0);
        }
        
        /* Tree Styles */
        .tree {
            font-family: var(--font-family);
            font-size: 13px;
            padding: 24px;
            background: var(--surface-color);
            border-radius: var(--radius-medium);
            margin: 16px;
            box-shadow: var(--shadow-light);
        }

        .tree-item {
            padding: 4px 8px;
            border-radius: var(--radius-small);
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: var(--transition);
            position: relative;
            margin: 1px 0;
        }

        .tree-item:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .tree-item.device {
            font-weight: 500;
            color: var(--text-primary);
        }

        .tree-item.device:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .tree-item.selected {
            background: rgba(99, 102, 241, 0.2);
            color: var(--text-primary);
        }

        .tree-item.search-match {
            background: rgba(77, 184, 100, 0.15);
            border-left: 2px solid var(--accent-color);
        }

        .tree-item.point {
            color: var(--text-secondary);
            padding-left: 32px;
        }

        .tree-item.point:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .delete-btn {

            width: 18px;
            height: 18px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            opacity: 0;
            transition: all 0.2s ease;
            margin-left: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .tree-item:hover .delete-btn {
            opacity: 1;
        }

        .delete-btn:hover {
            background: #dc2626;
        }

        /* Excluded items styles */
        .tree-item.excluded {
            opacity: 0.5;
            text-decoration: line-through;
            background: rgba(255, 255, 255, 0.05);
        }

        .tree-item.excluded .device-checkbox {
            pointer-events: none;
            opacity: 0.3;
        }

        .tree-item.excluded .node-name {
            color: #666;
        }

        .tree-item.excluded .delete-btn {
            background: #28a745;
            color: white;
        }

        .tree-item.excluded .delete-btn:hover {
            background: #059669;
        }

        /* Expand button styles */
        .expand-btn {
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            flex-shrink: 0;
            transition: all 0.2s ease;
            color: var(--text-secondary);
        }

        .expand-btn:hover {
            color: var(--text-primary);
        }

        .expand-spacer {
            width: 16px;
            height: 16px;
            flex-shrink: 0;
        }

        .node-icon {
            flex-shrink: 0;
        }

        .node-name {
            flex-grow: 1;
        }

        .tree-children {
            margin-left: 24px;
            display: none;
            border-left: 2px solid var(--border-color);
            margin-top: 4px;
            padding-left: 8px;
        }

        .tree-children.open {
            display: block;
        }

        .tree-icon {
            color: var(--accent-color);
        }

        .tree-icon.device {
            color: var(--success-color);
        }

        .tree-icon.junk {
            color: var(--text-muted);
        }
        
        .point {
            padding: 6px 12px;
            border-radius: var(--radius-small);
            cursor: copy;
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--text-secondary);
            transition: var(--transition);
            margin: 1px 0;
        }

        .point:hover {
            background: #1e40af20;
            color: var(--accent-color);
        }

        .point-icon {
            width: 12px;
            height: 12px;
            fill: var(--accent-color);
            flex-shrink: 0;
        }

        .point-name {
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 12px;
        }
        
        /* Templates Report */
        .templates-report {
            padding: 20px;
        }

        /* Reflow Builder */
        .reflow-builder {
            padding: 20px;
            max-width: 1200px;
        }

        .reflow-container {
            background: var(--surface-color);
            border-radius: 8px;
            padding: 30px;
            box-shadow: var(--shadow-medium);
        }

        .reflow-section {
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .reflow-section:last-child {
            border-bottom: none;
        }

        .reflow-section h3 {
            color: var(--text-primary);
            margin-bottom: 15px;
            font-size: 18px;
        }

        .template-select {
            width: 100%;
            max-width: 500px;
            padding: 12px;
            border: 2px solid var(--border-color);
            border-radius: 6px;
            font-size: 14px;
            background: var(--surface-color);
            color: var(--text-primary);
        }

        .template-preview {
            background: var(--background-color);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 15px;
            margin-top: 15px;
        }

        .points-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 8px;
            margin-top: 10px;
        }

        .point-item {
            background: var(--surface-color);
            padding: 8px 12px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            font-size: 12px;
            font-family: 'Courier New', monospace;
            color: var(--text-primary);
        }

        .partial-matches-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .partial-match-item {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 15px;
        }

        .partial-match-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .partial-match-similarity {
            color: var(--success-color);
            font-weight: 500;
            margin-left: 10px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #333;
        }

        .form-control {
            width: 100%;
            max-width: 400px;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
        }

        /* Reflow Regex Gen */
        .regex-gen-container {
            background: var(--surface-color);
            border-radius: 8px;
            padding: 30px;
            box-shadow: var(--shadow-medium);
            max-width: 1200px;
        }

        .regex-gen-header {
            margin-bottom: 24px;
        }

        .regex-gen-header h2 {
            color: var(--text-primary);
            margin-bottom: 8px;
            font-size: 24px;
        }

        .regex-gen-header p {
            color: var(--text-secondary);
            font-size: 14px;
        }

        .regex-import-section {
            background: rgba(77, 184, 100, 0.1);
            border: 1px solid rgba(77, 184, 100, 0.3);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 24px;
        }

        .regex-import-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
            cursor: pointer;
        }

        .regex-import-header h3 {
            color: var(--accent-color);
            font-size: 16px;
            font-weight: 600;
        }

        .regex-import-content {
            display: none;
        }

        .regex-import-content.expanded {
            display: block;
        }

        .regex-import-input-group {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .regex-import-input {
            flex: 1;
            padding: 10px 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-small);
            background: var(--background-color);
            color: var(--text-primary);
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 13px;
        }

        .regex-import-status {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            margin-top: 8px;
        }

        .regex-import-status.success {
            color: var(--success-color);
        }

        .regex-import-status.error {
            color: var(--error-color);
        }

        .regex-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
            margin-bottom: 32px;
        }

        .regex-input-section,
        .regex-output-section {
            display: flex;
            flex-direction: column;
        }

        .regex-section-title {
            color: var(--text-primary);
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 12px;
        }

        .regex-section-description {
            color: var(--text-secondary);
            font-size: 13px;
            margin-bottom: 16px;
        }

        .regex-point-inputs {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 12px;
        }

        .regex-point-input-row {
            display: flex;
            gap: 8px;
        }

        .regex-point-input {
            flex: 1;
            padding: 10px 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-small);
            background: var(--background-color);
            color: var(--text-primary);
            font-size: 14px;
        }

        .regex-point-input:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px rgba(77, 184, 100, 0.2);
        }

        .regex-remove-btn {
            padding: 10px 12px;
            background: transparent;
            border: none;
            color: var(--error-color);
            cursor: pointer;
            border-radius: var(--radius-small);
            transition: var(--transition);
        }

        .regex-remove-btn:hover {
            background: rgba(239, 68, 68, 0.1);
        }

        .regex-add-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 16px;
            background: transparent;
            border: none;
            color: var(--accent-color);
            cursor: pointer;
            font-size: 14px;
            border-radius: var(--radius-small);
            transition: var(--transition);
        }

        .regex-add-btn:hover {
            background: rgba(77, 184, 100, 0.1);
        }

        .regex-output-container {
            position: relative;
            background: var(--background-color);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-small);
            padding: 16px;
            min-height: 80px;
            margin-bottom: 12px;
        }

        .regex-output-text {
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 14px;
            color: var(--text-primary);
            word-break: break-all;
            padding-right: 40px;
        }

        .regex-output-placeholder {
            color: var(--text-muted);
            font-style: italic;
        }

        .regex-copy-btn {
            position: absolute;
            top: 12px;
            right: 12px;
            padding: 8px;
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-small);
            color: var(--text-secondary);
            cursor: pointer;
            transition: var(--transition);
        }

        .regex-copy-btn:hover {
            color: var(--accent-color);
            border-color: var(--accent-color);
        }

        .regex-copy-success {
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--success-color);
            font-size: 13px;
            margin-bottom: 12px;
        }

        .regex-usage-info {
            background: rgba(77, 184, 100, 0.1);
            border: 1px solid rgba(77, 184, 100, 0.3);
            border-radius: var(--radius-small);
            padding: 16px;
        }

        .regex-usage-info h4 {
            color: var(--accent-color);
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .regex-usage-info ol {
            margin-left: 20px;
            color: var(--text-secondary);
            font-size: 13px;
        }

        .regex-usage-info ol li {
            margin-bottom: 4px;
        }

        .regex-test-section {
            margin-top: 32px;
            padding-top: 24px;
            border-top: 1px solid var(--border-color);
        }

        .regex-test-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
            margin-top: 16px;
        }

        .regex-test-label {
            display: block;
            color: var(--text-primary);
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 8px;
        }

        .regex-test-input {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-small);
            background: var(--background-color);
            color: var(--text-primary);
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 13px;
            resize: vertical;
        }

        .regex-test-input:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px rgba(77, 184, 100, 0.2);
        }

        .regex-test-results {
            border: 1px solid var(--border-color);
            border-radius: var(--radius-small);
            padding: 16px;
            background: var(--background-color);
            min-height: 156px;
        }

        .regex-test-result-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            margin-bottom: 8px;
        }

        .regex-test-result-item.match {
            color: var(--success-color);
        }

        .regex-test-result-item.no-match {
            color: var(--error-color);
        }

        .regex-test-icon {
            width: 16px;
            height: 16px;
            display: inline-block;
        }

        .regex-notes {
            background: rgba(245, 158, 11, 0.1);
            border: 1px solid rgba(245, 158, 11, 0.3);
            border-radius: var(--radius-small);
            padding: 16px;
            margin-top: 24px;
        }

        .regex-notes-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .regex-notes-title {
            color: var(--warning-color);
            font-size: 14px;
            font-weight: 600;
        }

        .regex-notes ul {
            margin-left: 20px;
            color: var(--text-secondary);
            font-size: 13px;
        }

        .regex-notes ul li {
            margin-bottom: 4px;
        }

        .summary-card {
            background: var(--sidebar-color);
            color: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .summary-stats {
            display: flex;
            gap: 40px;
            margin-top: 15px;
        }
        
        .stat {
            display: flex;
            flex-direction: column;
        }
        
        .stat-value {
            font-size: 32px;
            font-weight: bold;
        }
        
        .stat-label {
            font-size: 12px;
            opacity: 0.9;
            text-transform: uppercase;
        }
        
        .template-card {
            background: var(--surface-color);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
        }
        
        .template-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 2px solid var(--border-color);
        }
        
        .template-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .template-count {
            background: #4db864;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
        }
        
        .device-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 8px;
            margin-top: 12px;
        }
        
        .device-item {
            background: var(--background-color);
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 13px;
            border-left: 3px solid var(--accent-color);
            cursor: help;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        /* Checkbox styles */
        .device-checkbox {
            width: 16px;
            height: 16px;
            margin-right: 8px;
            cursor: pointer;
            accent-color: var(--accent-color);
            flex-shrink: 0;
        }

        .tree-item.device-checked {
            background: rgba(77, 184, 100, 0.1);
            border-left: 3px solid var(--accent-color);
        }

        .template-controls {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
            padding: 8px;
            background: rgba(0, 102, 204, 0.05);
            border-radius: 6px;
            border: 1px solid rgba(0, 102, 204, 0.1);
        }

        .template-control-btn {
            padding: 4px 12px;
            border: 1px solid var(--border-color);
            background: var(--surface-color);
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s ease;
            color: var(--text-primary);
        }

        .template-control-btn:hover {
            background: var(--background-color);
            transform: translateY(-1px);
        }

        .template-control-btn.check-all {
            color: var(--success-color);
            border-color: var(--success-color);
        }

        .template-control-btn.check-all:hover {
            background: rgba(40, 167, 69, 0.1);
        }

        .template-control-btn.uncheck-all {
            color: var(--danger-color);
            border-color: var(--danger-color);
        }

        .template-control-btn.uncheck-all:hover {
            background: rgba(220, 53, 69, 0.1);
        }
        
        .points-summary {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border-color);
            font-size: 12px;
            color: var(--text-secondary);
        }

        .points-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .expand-points-btn {
            background: none;
            border: none;
            cursor: pointer;
            color: var(--accent-color);
            font-size: 12px;
            padding: 2px 6px;
            border-radius: 3px;
            transition: var(--transition);
        }

        .expand-points-btn:hover {
            background: var(--accent-color);
            color: white;
        }

        .points-expanded {
            margin-top: 8px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 4px;
        }


        .template-point-item {
            padding: 4px 8px;
            background: var(--sidebar-color);
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            color: var(--text-primary);
            transition: var(--transition);
        }

        .template-point-item:hover {
            background: var(--accent-color);
            color: white;
        }
        /* Template Naming and Time Inputs */
        .template-name-input {
            background: transparent;
            border: 1px solid transparent;
            font-weight: 600;
            font-size: 16px;
            padding: 4px 8px;
            border-radius: 4px;
            color: inherit;
            width: 100%;
            max-width: 300px;
        }

        .template-name-input:hover,
        .template-name-input:focus {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
            outline: none;
        }

        .template-time-input-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 12px;
            font-size: 14px;
            color: #6c757d;
        }

        .template-hours-input {
            width: 80px;
            padding: 4px 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: white;
            color: var(--text-primary);
            font-size: 14px;
        }

        .template-hours-input:hover,
        .template-hours-input:focus {
            border-color: var(--accent-color);
            background: #f8f9fa;
            outline: none;
        }

        .template-hours-input::placeholder {
            color: #6c757d;
        }

        /* Detail Panel */
        .detail-header {
            background: var(--accent-color);
            color: white;
            padding: 20px 24px;
            margin: 0;
            box-shadow: var(--shadow-light);
        }

        .detail-header h3 {
            margin: 0 0 8px 0;
            font-size: 18px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .detail-header .device-path {
            font-size: 12px;
            opacity: 0.9;
            font-family: 'Monaco', 'Menlo', monospace;
        }

        .detail-section {
            margin: 16px 24px;
            padding: 16px;
            background: var(--background-color);
            border-radius: var(--radius-medium);
            border: 1px solid var(--border-color);
        }

        .detail-section h4 {
            margin: 0 0 12px 0;
            font-size: 14px;
            font-weight: 600;
            color: var(--primary-color);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        /* Clickable device links in detail panel */
        .device-link {
            padding: 4px 8px;
            margin: 4px 0;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .device-link:hover {
            background: #4db864 !important;
            color: white !important;
            transform: translateX(4px);
        }

        .device-link.current {
            background: #4db864;
            color: white;
        }
        
        /* Copyable points in detail panel */
        .detail-point {
            padding: 4px;
            margin: 2px 0;
            cursor: copy;
            border-radius: 4px;
            transition: all 0.2s;
            color: white;
            display: flex;
            align-items: center;
        }

        .detail-point:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(2px);
        }
        
        /* Partial match differences */
        .diff-point {
            padding: 3px 6px;
            margin: 2px 0;
            border-radius: 3px;
            font-size: 11px;
        }
        
        .diff-point.missing {
            background: #ffebee;
            color: #c62828;
        }
        
        .diff-point.extra {
            background: #e8f5e9;
            color: #2e7d32;
        }
        
        /* Status */
        .file-info {
            padding: 16px;
            background: var(--surface-color);
            border-radius: var(--radius-medium);
            margin-bottom: 24px;
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-light);
        }

        .file-info strong {
            color: var(--text-primary);
            font-weight: 600;
        }

        /* Configuration Panel, Export Section, Tips Section - REMOVED */

        .stats-mini {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 24px;
        }

        .stat-mini {
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            padding: 16px;
            border-radius: var(--radius-medium);
            text-align: center;
            box-shadow: var(--shadow-light);
            transition: var(--transition);
            position: relative;
            overflow: hidden;
        }

        .stat-mini:hover {
            box-shadow: var(--shadow-medium);
            transform: translateY(-2px);
        }

        .stat-mini::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--accent-color);
        }

        .stat-mini-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .stat-mini-label {
            font-size: 11px;
            color: var(--text-secondary);
            text-transform: uppercase;
            font-weight: 500;
            letter-spacing: 0.5px;
        }
        
        /* Toast */
        .toast {
            position: fixed;
            bottom: 24px;
            right: 24px;
            background: var(--surface-color);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: 16px 20px;
            border-radius: var(--radius-medium);
            box-shadow: var(--shadow-heavy);
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 12px;
            font-weight: 500;
            max-width: 350px;
        }

        .toast.show {
            transform: translateY(0);
            opacity: 1;
        }

        .toast.success {
            border-left: 4px solid var(--success-color);
        }

        .toast.error {
            border-left: 4px solid var(--error-color);
        }

        .toast.warning {
            border-left: 4px solid var(--warning-color);
        }

        .toast-icon {
            width: 16px;
            height: 16px;
            flex-shrink: 0;
        }

        .toast.success .toast-icon {
            color: var(--success-color);
        }

        .toast.error .toast-icon {
            color: var(--error-color);
        }

        .toast.warning .toast-icon {
            color: var(--warning-color);
        }
        
        input[type="file"] {
            display: none;
        }

        /* SVG Icons */
        .icon {
            width: 16px;
            height: 16px;
            fill: currentColor;
            flex-shrink: 0;
        }

        .icon-large {
            width: 20px;
            height: 20px;
        }

        /* Graphics Review */
        .graphics-review {
            padding: 20px;
            max-width: 1400px;
        }

        .folder-info {
            background: var(--surface-color);
            padding: 16px;
            border-radius: var(--radius-medium);
            margin: 16px 0;
            border: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .folder-info-text {
            flex: 1;
        }

        .folder-name {
            font-weight: 600;
            color: var(--primary-color);
            font-size: 15px;
        }

        .folder-stats {
            color: var(--text-secondary);
            font-size: 13px;
            margin-top: 4px;
        }

        .graphic-item {
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-medium);
            padding: 16px;
            margin-bottom: 12px;
            transition: var(--transition);
        }

        .graphic-item:hover {
            box-shadow: var(--shadow-medium);
            border-color: var(--accent-color);
        }

        .graphic-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border-color);
        }

        .graphic-title {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 15px;
            word-break: break-word;
        }

        .graphic-path {
            color: var(--text-muted);
            font-size: 12px;
            font-family: 'Monaco', 'Menlo', monospace;
            margin-top: 4px;
        }

        .equipment-match {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
            padding: 10px;
            background: var(--background-color);
            border-radius: var(--radius-small);
        }

        .match-label {
            font-weight: 500;
            color: var(--text-secondary);
            font-size: 13px;
        }

        .match-device {
            font-family: 'Monaco', 'Menlo', monospace;
            color: var(--primary-color);
            font-size: 13px;
            font-weight: 600;
        }

        .confidence-badge {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .confidence-high {
            background: rgba(39, 174, 96, 0.1);
            color: var(--success-color);
            border: 1px solid rgba(39, 174, 96, 0.3);
        }

        .confidence-medium {
            background: rgba(243, 156, 18, 0.1);
            color: var(--warning-color);
            border: 1px solid rgba(243, 156, 18, 0.3);
        }

        .confidence-low {
            background: rgba(231, 76, 60, 0.1);
            color: var(--error-color);
            border: 1px solid rgba(231, 76, 60, 0.3);
        }

        .issue-list {
            margin-top: 12px;
        }

        .issue-item {
            padding: 8px 12px;
            margin-bottom: 6px;
            border-radius: var(--radius-small);
            font-size: 13px;
            display: flex;
            align-items: flex-start;
            gap: 8px;
        }

        .issue-item.error {
            background: rgba(231, 76, 60, 0.1);
            border-left: 3px solid var(--error-color);
            color: var(--error-color);
        }

        .issue-item.warning {
            background: rgba(243, 156, 18, 0.1);
            border-left: 3px solid var(--warning-color);
            color: var(--warning-color);
        }

        .issue-item.info {
            background: rgba(52, 152, 219, 0.1);
            border-left: 3px solid var(--accent-color);
            color: var(--accent-color);
        }

        .issue-icon {
            flex-shrink: 0;
            font-weight: 700;
            font-size: 14px;
        }

        .issue-text {
            flex: 1;
            word-break: break-word;
        }

        .point-name-code {
            font-family: 'Monaco', 'Menlo', monospace;
            font-weight: 600;
            background: rgba(0, 0, 0, 0.05);
            padding: 2px 6px;
            border-radius: 3px;
        }


        .select-folder-btn {
            padding: 14px 24px;
            font-size: 15px;
            font-weight: 600;
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: var(--radius-medium);
            cursor: pointer;
            transition: var(--transition);
            display: inline-flex;
            align-items: center;
            gap: 10px;
            box-shadow: var(--shadow-light);
        }

        .select-folder-btn:hover:not(:disabled):not(.disabled) {
            background: #4db864;
            transform: translateY(-2px);
            box-shadow: var(--shadow-medium);
        }

        .select-folder-btn:disabled,
        .select-folder-btn.disabled {
            background: var(--text-muted);
            cursor: not-allowed;
            opacity: 0.6;
            pointer-events: none;
        }
        .graphics-empty-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-secondary);
        }

        .graphics-empty-state svg {
            width: 80px;
            height: 80px;
            margin-bottom: 20px;
            opacity: 0.3;
        }

        /* Expandable missing points */
        .issue-item.expandable {
            cursor: pointer;
            user-select: none;
        }

        .issue-item.expandable:hover {
            background: rgba(255, 255, 255, 0.03);
        }

        .issue-item.expandable .issue-text::after {
            content: ' ▼';
            font-size: 10px;
            margin-left: 8px;
            opacity: 0.6;
        }

        .issue-item.expandable.expanded .issue-text::after {
            content: ' ▲';
        }

        .missing-points-detail {
            margin-top: 8px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            font-size: 12px;
            line-height: 1.6;
            display: none;
        }

        .missing-points-detail.visible {
            display: block;
        }

        .missing-points-list {
            margin-top: 8px;
            color: var(--text-secondary);
            max-height: 400px;
            overflow-y: auto;
        }

        .missing-point {
            display: inline-block;
            margin: 2px 4px 2px 0;
            padding: 2px 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }

        /* Modal Styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        .modal-content {
            background: var(--surface-color);
            border-radius: var(--radius-medium);
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-heavy);
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            padding: 20px 24px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h2 {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
            margin: 0;
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 28px;
            line-height: 1;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: var(--radius-small);
            transition: var(--transition);
        }

        .modal-close:hover {
            background: var(--background-color);
            color: var(--text-primary);
        }

        .modal-body {
            padding: 24px;
            overflow-y: auto;
            flex: 1;
        }

        .form-group {
            margin-bottom: 16px;
        }

        .form-group label {
            display: block;
            color: var(--text-secondary);
            font-size: 12px;
            font-weight: 500;
            margin-bottom: 6px;
        }

        .modal-body input,
        .modal-body select {
            width: 100%;
            padding: 10px 12px;
            background: var(--background-color);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-small);
            color: var(--text-primary);
            font-size: 13px;
            transition: var(--transition);
        }

        .modal-body input:focus,
        .modal-body select:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px rgba(77, 184, 100, 0.2);
        }

        .modal-body input::placeholder {
            color: var(--text-muted);
        }

        .modal-body > div {
            color: var(--text-secondary);
            font-size: 12px;
            padding: 12px;
            background: rgba(245, 158, 11, 0.1);
            border-left: 3px solid var(--warning-color);
            border-radius: var(--radius-small);
            margin-top: 12px;
        }

        .modal-footer {
            padding: 16px 24px;
            border-top: 1px solid var(--border-color);
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .modal-footer button {
            padding: 10px 20px;
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-small);
            color: var(--text-primary);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
        }

        .modal-footer button:hover {
            background: var(--background-color);
            border-color: var(--text-muted);
        }

        .modal-footer button:last-child {
            background: var(--accent-color);
            border-color: var(--accent-color);
            color: white;
        }

        .modal-footer button:last-child:hover {
            background: #2563eb;
            border-color: #2563eb;
        }

        /* Help Modal Styles */
        .help-nav {
            width: 280px;
            border-right: 1px solid var(--border-color);
            overflow-y: auto;
            padding: 20px 0;
        }

        .help-nav-section {
            padding: 12px 20px 8px 20px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-muted);
        }

        .help-nav-item {
            padding: 10px 20px 10px 32px;
            cursor: pointer;
            color: var(--text-secondary);
            font-size: 13px;
            transition: var(--transition);
            border-left: 3px solid transparent;
        }

        .help-nav-item:hover {
            background: var(--hover-color);
            color: var(--text-primary);
        }

        .help-nav-item.active {
            background: rgba(77, 184, 100, 0.1);
            color: var(--accent-color);
            border-left-color: var(--accent-color);
            font-weight: 500;
        }

        .help-content {
            flex: 1;
            overflow-y: auto;
            padding: 30px 40px;
        }

        .help-content h1 {
            font-size: 28px;
            font-weight: 700;
            color: var(--text-primary);
            margin: 0 0 8px 0;
        }

        .help-content h2 {
            font-size: 20px;
            font-weight: 600;
            color: var(--text-primary);
            margin: 32px 0 16px 0;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border-color);
        }

        .help-content h3 {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
            margin: 24px 0 12px 0;
        }

        .help-content p {
            font-size: 14px;
            line-height: 1.7;
            color: var(--text-secondary);
            margin: 12px 0;
        }

        .help-content ul, .help-content ol {
            margin: 12px 0;
            padding-left: 24px;
            color: var(--text-secondary);
        }

        .help-content li {
            margin: 8px 0;
            line-height: 1.6;
        }

        .help-content code {
            background: var(--background-color);
            border: 1px solid var(--border-color);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: var(--accent-color);
        }

        .help-content pre {
            background: var(--background-color);
            border: 1px solid var(--border-color);
            padding: 16px;
            border-radius: 6px;
            overflow-x: auto;
            margin: 16px 0;
        }

        .help-content pre code {
            background: none;
            border: none;
            padding: 0;
            color: var(--text-primary);
        }

        .help-info-box {
            background: rgba(77, 184, 100, 0.1);
            border-left: 4px solid var(--accent-color);
            padding: 16px;
            border-radius: 4px;
            margin: 20px 0;
        }

        .help-info-box strong {
            color: var(--accent-color);
            display: block;
            margin-bottom: 8px;
        }

        .help-warning-box {
            background: rgba(245, 158, 11, 0.1);
            border-left: 4px solid var(--warning-color);
            padding: 16px;
            border-radius: 4px;
            margin: 20px 0;
        }

        .help-warning-box strong {
            color: var(--warning-color);
            display: block;
            margin-bottom: 8px;
        }

        .help-steps {
            counter-reset: step-counter;
            list-style: none;
            padding-left: 0;
        }

        .help-steps li {
            counter-increment: step-counter;
            position: relative;
            padding-left: 40px;
            margin: 20px 0;
        }

        .help-steps li::before {
            content: counter(step-counter);
            position: absolute;
            left: 0;
            top: 0;
            width: 28px;
            height: 28px;
            background: var(--accent-color);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <!-- SVG Icon Definitions -->
    <svg style="display: none">
        <defs>
            <symbol id="icon-folder" viewBox="0 0 24 24">
                <path d="M10 4H4c-1.11 0-2 .89-2 2v12c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2h-8l-2-2z"/>
            </symbol>
            <symbol id="icon-tree" viewBox="0 0 24 24">
                <path d="M22 11V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3z"/>
            </symbol>
            <symbol id="icon-templates" viewBox="0 0 24 24">
                <path d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 2 2h16c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z"/>
            </symbol>
            <symbol id="icon-expand" viewBox="0 0 24 24">
                <path d="M12 5.83L15.17 9l1.41-1.41L12 3 7.41 7.59 8.83 9 12 5.83zm0 12.34L8.83 15l-1.41 1.41L12 21l4.59-4.59L15.17 15 12 18.17z"/>
            </symbol>
            <symbol id="icon-collapse" viewBox="0 0 24 24">
                <path d="M7.41 18.59L8.83 20 12 16.83 15.17 20l1.41-1.41L12 14l-4.59 4.59zm9.18-13.18L15.17 4 12 7.17 8.83 4 7.41 5.41 12 10l4.59-4.59z"/>
            </symbol>
            <symbol id="icon-close" viewBox="0 0 24 24">
                <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
            </symbol>
            <symbol id="icon-upload" viewBox="0 0 24 24">
                <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"/>
            </symbol>
            <symbol id="icon-chart" viewBox="0 0 24 24">
                <path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z"/>
            </symbol>
            <symbol id="icon-reflow" viewBox="0 0 39.23 43.5">
                <path d="M20.23,24.62c-3.15,2.26-6.35,4.57-10.9,4.57-2.59,0-5.64-.77-9.34-2.72v3.61c0,1.81.98,3.5,2.55,4.41l8.7,5.02c2.76-.54,5-2.14,7.46-3.91,4.73-3.41,9.98-7.16,20.1-4.02.15-.48.23-.98.23-1.5v-8.78c-9.57-3.3-14.26.04-18.81,3.32Z"/>
                <path d="M36.5,9.01l-3.74-2.16c-5.6-.31-9.1,2.2-12.52,4.66-3.15,2.26-6.35,4.57-10.9,4.57C6.74,16.08,3.7,15.31,0,13.37c0,.02,0,.03,0,.05v10.08c9.55,5.55,13.65,2.63,18.71-1,4.77-3.43,10.07-7.21,20.34-3.95v-5.13c0-1.81-.98-3.5-2.55-4.41Z"/>
                <path d="M20.23,37.72c-1.86,1.34-3.74,2.69-5.91,3.57l2.65,1.53c1.57.91,3.52.91,5.09,0l14.43-8.33c.31-.18.58-.39.84-.62-8.44-2.35-12.83.78-17.1,3.85Z"/>
                <path d="M18.71,9.39c2.82-2.03,5.83-4.17,9.93-4.92l-6.57-3.79c-.79-.45-1.67-.68-2.55-.68s-1.76.23-2.55.68L2.55,9.01c-.76.44-1.38,1.07-1.82,1.8,9.04,4.98,13.05,2.13,17.98-1.42Z"/>
            </symbol>
        </defs>
    </svg>
    <div class="app">

    <div class="header">
        <!-- Left side - Logo and navigation tabs -->
        <div style="display: flex; align-items: center; gap: 16px;">
            <div class="logo" id="logoText" onmouseenter="typeLogoText()" onmouseleave="resetLogoText()">[nsk]</div>
            
            <div style="width: 1px; height: 32px; background: var(--border-color);"></div>
            
        </div>

        <!-- Right side - Help button -->
        <div style="margin-left: auto;">
            <button class="header-tab" onclick="openHelpModal()" title="Help Documentation">
                <i data-lucide="help-circle" style="width: 16px; height: 16px;"></i>
                Help
            </button>
        </div>
    </div>
        <div class="toolbar">

            <!-- Station Sub-tabs -->
            <div class="sub-tabs-container active" id="stationSubTabs">
                <div class="sub-tabs">
                    <button class="sub-tab active" onclick="showView('tree')">
                        <svg class="icon"><use href="#icon-tree"></use></svg>
                        Tree
                    </button>
                    <button class="sub-tab" onclick="showView('templates')">
                        <svg class="icon"><use href="#icon-templates"></use></svg>
                        Templates
                    </button>
                    <button class="sub-tab" onclick="showView('comparison')">
                        <i data-lucide="git-compare" style="width: 16px; height: 16px; margin-right: 6px;"></i>
                        Comparison
                    </button>
                </div>
                <div class="search-bar" style="flex: 1; max-width: 300px;">
                    <i data-lucide="search" style="position: absolute; left: 12px; top: 50%; transform: translateY(-50%); width: 16px; height: 16px; color: var(--text-muted);"></i>
                    <input type="text" id="treeSearchInput" placeholder="Search devices and points..." oninput="filterTree(this.value)" />
                    <button id="clearSearchBtn" onclick="clearSearch()" style="display: none; position: absolute; right: 8px; top: 50%; transform: translateY(-50%); background: none; border: none; cursor: pointer; padding: 4px; color: var(--text-muted);">
                        <i data-lucide="x" style="width: 16px; height: 16px;"></i>
                    </button>
                </div>
                <div class="tree-controls active" id="treeControls">
                    <button class="btn" onclick="expandAll()">
                        <svg class="icon"><use href="#icon-expand"></use></svg>
                        Expand
                    </button>
                    <button class="btn" onclick="collapseAll()">
                        <svg class="icon"><use href="#icon-collapse"></use></svg>
                        Collapse
                    </button>
                    <button class="btn" onclick="closeDetail()">
                        <svg class="icon"><use href="#icon-close"></use></svg>
                        Close Detail
                    </button>
                </div>
            </div>

        </div>

        <div class="main">
            
            <div class="sidebar">

                <!-- File Info -->
                <div style="padding: 16px 0; display: flex; flex-direction: column; gap: 8px;">
                    <button class="icon-button" onclick="openFile()" style="width: 100%; justify-content: flex-start; padding: 10px 12px;">
                        <i data-lucide="upload" style="width: 16px; height: 16px; margin-right: 12px;"></i>
                        OPEN CSV
                    </button>

                    <!-- BQL Query Info -->
                    <div style="background: rgba(59, 130, 246, 0.1); border: 1px solid rgba(59, 130, 246, 0.3); border-radius: 6px; padding: 12px; margin-top: 8px;">
                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                            <i data-lucide="info" style="width: 14px; height: 14px; color: var(--accent-color);"></i>
                            <span style="font-size: 11px; font-weight: 600; color: var(--accent-color); text-transform: uppercase; letter-spacing: 0.5px;">Niagara BQL Query</span>
                        </div>
                        <div style="font-family: 'Monaco', 'Menlo', monospace; font-size: 11px; color: var(--text-secondary); background: rgba(0,0,0,0.3); padding: 8px; border-radius: 4px; word-break: break-all; line-height: 1.4;">
                            station:|slot:/Drivers|bql:select slotPath, type as 'Point Type', facets from control:ControlPoint
                        </div>
                        <button onclick="copyBqlQuery()" style="margin-top: 8px; padding: 6px 10px; background: var(--accent-color); color: white; border: none; border-radius: 4px; font-size: 11px; cursor: pointer; width: 100%; font-weight: 500; transition: var(--transition);" onmouseover="this.style.background='#2563eb'" onmouseout="this.style.background='var(--accent-color)'">
                            <i data-lucide="copy" style="width: 12px; height: 12px; margin-right: 4px; vertical-align: middle;"></i>
                            Copy Query
                        </button>
                    </div>
                </div>

                <div style="height: 1px; background: var(--border-color); margin: 0 16px;"></div>

                <!-- File Info Display -->
                <div style="padding: 16px; display: flex; flex-direction: column; gap: 12px;">
                    <div>
                        <p style="font-size: 12px; color: var(--text-secondary);"><strong>File:</strong> <span id="fileName">None</span></p>
                        <div id="compareFileInfo" style="display: none; margin-top: 4px;">
                            <p style="font-size: 12px; color: var(--text-secondary);"><strong>Compare:</strong> <span id="compareFileName">None</span></p>
                        </div>
                    </div>

                    <!-- Comparison Buttons -->
                    <div id="comparisonButtons" style="display: flex; flex-direction: column; gap: 8px;">
                        <button class="btn" onclick="openCompareFile()" id="compareBogBtn" style="width: 100%; display: none; font-size: 13px;">
                            <i data-lucide="upload" style="width: 14px; height: 14px; margin-right: 6px;"></i>
                            Compare CSV
                        </button>
                        <button class="btn" onclick="clearComparison()" id="clearComparisonBtn" style="width: 100%; display: none; font-size: 13px;">
                            <i data-lucide="x" style="width: 14px; height: 14px; margin-right: 6px;"></i>
                            Clear Comparison
                        </button>
                        <button class="btn" onclick="showView('comparison')" id="comparisonBtn" style="width: 100%; display: none; font-size: 13px;">
                            <i data-lucide="bar-chart-3" style="width: 14px; height: 14px; margin-right: 6px;"></i>
                            View Comparison
                        </button>
                    </div>

                    <!-- Hidden file inputs -->
                    <input type="file" id="fileInput" accept=".csv" onchange="loadFile(event)" style="display: none;">
                    <input type="file" id="compareFileInput" accept=".csv" onchange="loadCompareFile(event)" style="display: none;">
                </div>

                <div style="height: 1px; background: var(--border-color); margin: 0 16px;"></div>

                <!-- Statistics -->
                <div style="padding: 16px; flex: 1;">
                    <h4 style="font-size: 11px; color: var(--text-muted); margin-bottom: 16px; text-transform: uppercase; letter-spacing: 0.5px;">STATISTICS</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                        <div style="background: rgba(255,255,255,0.03); border: 1px solid var(--border-color); border-radius: 6px; padding: 12px;">
                            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 4px;">
                                <i data-lucide="server" style="width: 16px; height: 16px; color: var(--text-muted);"></i>
                            </div>
                            <div style="font-size: 24px; font-family: monospace; color: var(--text-primary);" id="deviceCount">0</div>
                            <div style="font-size: 10px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px;">DEVICES</div>
                        </div>
                        
                        <div style="background: rgba(255,255,255,0.03); border: 1px solid var(--border-color); border-radius: 6px; padding: 12px;">
                            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 4px;">
                                <i data-lucide="zap" style="width: 16px; height: 16px; color: var(--text-muted);"></i>
                            </div>
                            <div style="font-size: 24px; font-family: monospace; color: var(--text-primary);" id="pointCount">0</div>
                            <div style="font-size: 10px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px;">POINTS</div>
                        </div>
                        
                        <div style="background: rgba(255,255,255,0.03); border: 1px solid var(--border-color); border-radius: 6px; padding: 12px;">
                            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 4px;">
                                <i data-lucide="file-spreadsheet" style="width: 16px; height: 16px; color: var(--text-muted);"></i>
                            </div>
                            <div style="font-size: 24px; font-family: monospace; color: var(--text-primary);" id="templateCount">0</div>
                            <div style="font-size: 10px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px;">TEMPLATES</div>
                        </div>
                        
                        <div style="background: rgba(255,255,255,0.03); border: 1px solid var(--border-color); border-radius: 6px; padding: 12px;">
                            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 4px;">
                                <i data-lucide="activity" style="width: 16px; height: 16px; color: var(--text-muted);"></i>
                            </div>
                            <div style="font-size: 24px; font-family: monospace; color: var(--text-primary);" id="partialCount">0</div>
                            <div style="font-size: 10px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px;">PARTIALS</div>
                        </div>
                    </div>
                </div>

                <div style="height: 1px; background: var(--border-color); margin: 0 16px;"></div>

                <!-- Clear Data Button -->
                <div style="padding: 16px;">
                    <button class="btn" onclick="clearAllData()" style="width: 100%; background: var(--error-color); color: white; border-color: var(--error-color); font-size: 13px;">
                        <i data-lucide="trash-2" style="width: 14px; height: 14px; margin-right: 6px;"></i>
                        Clear Stored Info
                    </button>
                </div>

            </div>
            <div class="content">
                <div id="treeView" class="tree"></div>
                <div id="templatesView" class="templates-report" style="display: none;"></div>
                <div id="reflowView" class="reflow-builder" style="display: none;">
                    <div class="reflow-container">
                        <h2>Reflow Template Builder</h2>
                        <p>Create Reflow point map exports from detected templates and partial matches.</p>

                        <div class="reflow-section">
                            <h3>1. Select Base Template</h3>
                            <select id="reflowTemplateSelect" class="template-select">
                                <option value="">Choose a template...</option>
                            </select>

                            <div id="reflowTemplatePreview" class="template-preview" style="display: none;">
                                <h4>Selected Template Points:</h4>
                                <div id="reflowTemplatePoints" class="points-list"></div>
                            </div>
                        </div>

                        <div id="reflowPartialMatchesSection" class="reflow-section" style="display: none;">
                            <h3>2. Include Additional Points (Optional)</h3>
                            <p>Select partial matches to include additional unique points:</p>
                            <div id="reflowPartialMatches" class="partial-matches-list"></div>
                        </div>

                        <div class="reflow-section">
                            <h3>3. Export Configuration</h3>
                            <div class="form-group">
                                <label for="reflowTitle">Title/Filename:</label>
                                <input type="text" id="reflowTitle" class="form-control" placeholder="Enter title for the export">
                            </div>
                        </div>

                        <div class="reflow-section">
                            <h3>4. Export Files</h3>
                            <button id="exportReflowCSVBtn" class="btn btn-primary" disabled>
                                Export Point Map (.csv)
                            </button>
                            <button id="exportReflowEquipmentBtn" class="btn btn-secondary" disabled style="margin-left: 10px;">
                                Export Equipment (.csv)
                            </button>
                        </div>
                    </div>
                </div>
                <div id="reflowRegexView" class="reflow-builder" style="display: none;">
                    <div class="regex-gen-container">
                        <div class="regex-gen-header">
                            <h2>🔧 Reflow Point Name Regex Generator</h2>
                            <p>Generate regex patterns for Tridium Niagara Reflow point mapping. Patterns are automatically formatted for Reflow (lowercase, wrapped in forward slashes).</p>
                        </div>

                        <!-- Import Existing Regex Section -->
                        <div class="regex-import-section">
                            <div class="regex-import-header" onclick="toggleRegexImport()">
                                <h3>Import Existing Regex (Optional)</h3>
                                <span id="regexImportToggleIcon">▼</span>
                            </div>
                            <div id="regexImportContent" class="regex-import-content">
                                <p style="color: var(--text-secondary); font-size: 13px; margin-bottom: 12px;">
                                    Have an existing regex pattern? Paste it here and we'll combine it with your new variations.
                                </p>
                                <div class="regex-import-input-group">
                                    <input
                                        id="regexExistingInput"
                                        type="text"
                                        placeholder="Paste existing regex (e.g., /discharge.*temp/ or discharge.*temp)"
                                        class="regex-import-input"
                                    />
                                    <button class="regex-remove-btn" onclick="clearRegexImport()">✕</button>
                                </div>
                                <div id="regexImportStatus" class="regex-import-status" style="display: none;"></div>
                            </div>
                        </div>

                        <div class="regex-grid">
                            <!-- Input Section -->
                            <div class="regex-input-section">
                                <h3 class="regex-section-title">Point Name Variations</h3>
                                <p class="regex-section-description">
                                    Enter all the variations of your point name you want to match:
                                </p>

                                <div id="regexPointInputs" class="regex-point-inputs">
                                    <!-- Dynamic point inputs will be added here -->
                                </div>

                                <button class="regex-add-btn" onclick="addRegexPointInput()">
                                    <span>+</span>
                                    Add Another Variation
                                </button>
                            </div>

                            <!-- Output Section -->
                            <div class="regex-output-section">
                                <h3 class="regex-section-title">Generated Regex</h3>

                                <div class="regex-output-container">
                                    <div id="regexOutput" class="regex-output-text regex-output-placeholder">
                                        Enter point names to generate regex...
                                    </div>
                                    <button id="regexCopyBtn" class="regex-copy-btn" onclick="copyRegexToClipboard()" style="display: none;">
                                        <i data-lucide="clipboard" style="width: 16px; height: 16px;"></i>
                                    </button>
                                </div>

                                <div id="regexCopySuccess" class="regex-copy-success" style="display: none;">
                                    Copied to clipboard!
                                </div>

                                <div class="regex-usage-info">
                                    <h4>Reflow Usage:</h4>
                                    <ol>
                                        <li>Copy the generated regex pattern</li>
                                        <li>In Reflow, set the point identifier type to "Regular Expression"</li>
                                        <li>Paste the pattern (including the forward slashes)</li>
                                        <li>Test with your actual point names below</li>
                                    </ol>
                                </div>
                            </div>
                        </div>

                        <!-- Test Section -->
                        <div class="regex-test-section">
                            <h3 class="regex-section-title">Test Your Regex</h3>
                            <div class="regex-test-grid">
                                <div>
                                    <label class="regex-test-label">
                                        Test Point Names (one per line):
                                    </label>
                                    <textarea
                                        id="regexTestInput"
                                        class="regex-test-input"
                                        rows="6"
                                        placeholder="discharge air temp&#10;da_temp&#10;supply air temperature&#10;mixed air temp"
                                    ></textarea>
                                </div>

                                <div>
                                    <label class="regex-test-label">
                                        Test Results:
                                    </label>
                                    <div id="regexTestResults" class="regex-test-results">
                                        <p style="color: var(--text-muted); font-size: 13px;">
                                            Enter test strings to see results...
                                        </p>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="regex-notes">
                            <div class="regex-notes-header">
                                <span style="font-size: 16px;">⚠️</span>
                                <span class="regex-notes-title">Important Notes:</span>
                            </div>
                            <ul>
                                <li>Reflow converts all point names to lowercase before matching</li>
                                <li>Always test your regex on regex101.com before using in Reflow</li>
                                <li>The generated pattern handles spaces and underscores automatically</li>
                                <li>More specific patterns are generally better than overly broad ones</li>
                            </ul>
                        </div>
                    </div>
                </div>
                <div id="comparisonView" class="templates-report" style="display: none;"></div>
                <div id="graphicsView" class="graphics-review" style="display: none;">
                    <div class="summary-card">
                        <h2>Graphics Review</h2>
                        <p style="margin-top: 10px; opacity: 0.9;">Scan Niagara PX (graphics) files and validate point references against loaded equipment data.</p>
                    </div>

                    <div style="margin: 20px 0;">
                        <input type="file" id="graphicsFolderInput" webkitdirectory directory multiple style="display: none;" onchange="handleGraphicsFolderSelection(event)" disabled>
                        <label for="graphicsFolderInput" class="select-folder-btn" id="selectFolderBtn" style="cursor: pointer; display: inline-flex;">
                            <svg class="icon" style="width: 20px; height: 20px;"><use href="#icon-folder"></use></svg>
                            Select Graphics Folder
                        </label>
                    </div>

                    <div style="margin: 20px 0;">
                        <div style="display: flex; gap: 12px; flex-wrap: wrap; align-items: flex-start;">
                            <input type="file" id="graphicsMappingInput" accept=".csv" style="display: none;" onchange="handleGraphicsMappingSelection(event)" disabled>
                            <label for="graphicsMappingInput" class="select-folder-btn" id="selectMappingBtn" style="cursor: pointer; display: inline-flex;">
                                <svg class="icon" style="width: 20px; height: 20px;"><use href="#icon-upload"></use></svg>
                                Graphics Mapping CSV
                            </label>
                            <button class="select-folder-btn" onclick="connectLiveGraphics()" style="cursor: pointer; display: inline-flex;" id="liveGraphicsBtn">
                                <svg class="icon" style="width: 20px; height: 20px;"><use href="#icon-upload"></use></svg>
                                Live Connect Graphics
                            </button>
                        </div>
                        <div style="margin-top: 10px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 4px; font-family: 'Courier New', monospace; font-size: 12px; color: var(--text-secondary);">
                            <div style="margin-bottom: 5px; color: var(--text-primary); font-weight: 500;">BQL Query (for reference):</div>
                            <code style="user-select: all;">station:|slot:/|bql:select parent.slotPath as 'Equip', displayName as 'View Name' from baja:PxView</code>
                        </div>
                    </div>

                    <div id="graphicsMappingInfo" style="display: none;"></div>
                    <div id="graphicsFolderInfo" style="display: none;"></div>
                    <div id="graphicsResults"></div>
                </div>

                <!-- Typo Check View -->
                <div id="typoCheckView" class="templates-report" style="display: none;">
                    <div class="summary-card">
                        <h2>Point Name Typo Checker</h2>
                        <p style="margin-top: 10px; opacity: 0.9;">Analyze point names for potential typos by finding similar patterns with low frequency.</p>
                        <div style="margin-top: 15px;">
                            <button class="btn primary" onclick="runTypoCheck()">
                                <i data-lucide="play" style="width: 16px; height: 16px;"></i>
                                Run Typo Check
                            </button>
                            <button class="btn" onclick="exportTypoReport()" id="exportTypoBtn" style="margin-left: 10px; display: none;">
                                <i data-lucide="download" style="width: 16px; height: 16px;"></i>
                                Export Report
                            </button>
                        </div>
                    </div>

                    <div id="typoCheckResults" style="margin-top: 20px;"></div>
                </div>

                <!-- Facet Check View -->
                <div id="facetCheckView" class="templates-report" style="display: none;">
                    <div class="summary-card">
                        <h2>Facet Checker</h2>
                        <p style="margin-top: 10px; opacity: 0.9;">Check point facets for null units and default boolean text values.</p>
                        <div style="margin-top: 15px;">
                            <button class="btn primary" onclick="runFacetCheck()">
                                <i data-lucide="play" style="width: 16px; height: 16px;"></i>
                                Run Facet Check
                            </button>
                            <button class="btn" onclick="exportFacetReport()" id="exportFacetBtn" style="margin-left: 10px; display: none;">
                                <i data-lucide="download" style="width: 16px; height: 16px;"></i>
                                Export Report
                            </button>
                        </div>
                    </div>

                    <div id="facetCheckResults" style="margin-top: 20px;"></div>
                </div>

                <!-- History Extension Check View -->
                <div id="historyCheckView" class="templates-report" style="display: none;">
                    <div class="summary-card">
                        <h2>History Extension Check</h2>
                        <p style="margin-top: 10px; opacity: 0.9;">Analyze history extensions for potentially missed assignments and check if extensions are enabled.</p>
                        <div style="margin-top: 15px;">
                            <label for="historyInput" class="select-folder-btn" style="cursor: pointer; display: inline-flex;">
                                <svg class="icon" style="width: 20px; height: 20px;"><use href="#icon-upload"></use></svg>
                                Load History CSV
                            </label>
                            <input type="file" id="historyInput" accept=".csv" onchange="loadHistoryCSV(event)" style="display: none;">
                            <button class="btn primary" onclick="runHistoryCheck()" id="runHistoryBtn" style="margin-left: 10px; display: none;">
                                <i data-lucide="play" style="width: 16px; height: 16px;"></i>
                                Run History Check
                            </button>
                        </div>
                        <div style="margin-top: 10px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 4px; font-family: 'Courier New', monospace; font-size: 12px; color: var(--text-secondary);">
                            <div style="margin-bottom: 5px; color: var(--text-primary); font-weight: 500;">BQL Query (for reference):</div>
                            <code style="user-select: all;">station:|slot:/Drivers|bql:select parent.slotPath as 'Slot Path', name as 'History Extension', enabled as 'Enabled' from baja:Component where (name = 'NumericInterval' or name = 'NumericCov' or name = 'BooleanInterval' or name = 'BooleanCov' or name = 'EnumInterval' or name = 'EnumCov' or name = 'StringInterval' or name = 'StringCov')</code>
                        </div>
                    </div>

                    <div id="historyCheckResults" style="margin-top: 20px;"></div>
                </div>

                <!-- Alarm Extension Check View -->
                <div id="alarmCheckView" class="templates-report" style="display: none;">
                    <div class="summary-card">
                        <h2>Alarm Extension Check</h2>
                        <p style="margin-top: 10px; opacity: 0.9;">Analyze alarm extensions for potentially missed assignments and check if extensions are enabled.</p>
                        <div style="margin-top: 15px;">
                            <label for="alarmInput" class="select-folder-btn" style="cursor: pointer; display: inline-flex;">
                                <svg class="icon" style="width: 20px; height: 20px;"><use href="#icon-upload"></use></svg>
                                Load Alarm CSV
                            </label>
                            <input type="file" id="alarmInput" accept=".csv" onchange="loadAlarmCSV(event)" style="display: none;">
                            <button class="btn primary" onclick="runAlarmCheck()" id="runAlarmBtn" style="margin-left: 10px; display: none;">
                                <i data-lucide="play" style="width: 16px; height: 16px;"></i>
                                Run Alarm Check
                            </button>
                        </div>
                        <div style="margin-top: 10px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 4px; font-family: 'Courier New', monospace; font-size: 12px; color: var(--text-secondary);">
                            <div style="margin-bottom: 5px; color: var(--text-primary); font-weight: 500;">BQL Query (for reference):</div>
                            <code style="user-select: all;">station:|slot:/Drivers|bql:select parent.slotPath as 'Point', name as 'Alarm Extension', enabled as 'Enabled' from baja:Component where (name = 'OutOfRangeAlarmExt' or name = 'FloatLimitAlarmExt' or name = 'StringChangeOfValueAlarmExt' or name = 'BooleanChangeOfStateAlarmExt' or name = 'BooleanCommandFailureAlarmExt' or name = 'EnumChangeOfStateAlarmExt' or name = 'EnumCommandFailureAlarmExt' or name = 'NumericChangeOfStateAlarmExt' or name = 'StatusAlarmExt')</code>
                        </div>
                    </div>

                    <div id="alarmCheckResults" style="margin-top: 20px;"></div>
                </div>

                <!-- Checkout Report View -->
                <div id="checkoutView" class="templates-report" style="display: none;">
                    <div class="summary-card">
                        <h2>Commissioning Checkout Report</h2>
                        <p style="margin-top: 10px; opacity: 0.9;">Generate a comprehensive commissioning report including equipment, templates, history extensions, and alarm extensions.</p>

                        <div style="margin-top: 20px; display: flex; gap: 20px; flex-wrap: wrap;">
                            <!-- Logo Upload -->
                            <div>
                                <label style="display: block; margin-bottom: 8px; font-weight: 500;">Company Logo (optional)</label>
                                <label for="checkoutLogoInput" class="select-folder-btn" style="cursor: pointer; display: inline-flex;">
                                    <i data-lucide="image" style="width: 16px; height: 16px;"></i>
                                    Upload Logo
                                </label>
                                <input type="file" id="checkoutLogoInput" accept="image/*" onchange="handleCheckoutLogoUpload(event)" style="display: none;">
                                <div id="logoPreview" style="margin-top: 10px; display: none;">
                                    <img id="logoPreviewImg" style="max-width: 200px; max-height: 80px; border-radius: 4px; border: 1px solid var(--border-color);">
                                    <button onclick="removeCheckoutLogo()" style="margin-left: 10px; padding: 4px 8px; background: var(--error-color); border: none; border-radius: 4px; color: white; cursor: pointer; font-size: 12px;">Remove</button>
                                </div>
                            </div>

                            <!-- History CSV Upload -->
                            <div>
                                <label style="display: block; margin-bottom: 8px; font-weight: 500;">History Extensions CSV</label>
                                <label for="checkoutHistoryInput" class="select-folder-btn" style="cursor: pointer; display: inline-flex;">
                                    <i data-lucide="clock" style="width: 16px; height: 16px;"></i>
                                    Load History CSV
                                </label>
                                <input type="file" id="checkoutHistoryInput" accept=".csv" onchange="loadCheckoutHistoryCSV(event)" style="display: none;">
                                <span id="checkoutHistoryStatus" style="margin-left: 10px; font-size: 12px; color: var(--text-secondary);"></span>
                            </div>

                            <!-- Alarm CSV Upload -->
                            <div>
                                <label style="display: block; margin-bottom: 8px; font-weight: 500;">Alarm Extensions CSV</label>
                                <label for="checkoutAlarmInput" class="select-folder-btn" style="cursor: pointer; display: inline-flex;">
                                    <i data-lucide="bell" style="width: 16px; height: 16px;"></i>
                                    Load Alarm CSV
                                </label>
                                <input type="file" id="checkoutAlarmInput" accept=".csv" onchange="loadCheckoutAlarmCSV(event)" style="display: none;">
                                <span id="checkoutAlarmStatus" style="margin-left: 10px; font-size: 12px; color: var(--text-secondary);"></span>
                            </div>
                        </div>

                        <div style="margin-top: 20px;">
                            <button class="btn primary" onclick="buildCheckoutReport()" id="buildCheckoutBtn" style="display: inline-flex;">
                                <i data-lucide="play" style="width: 16px; height: 16px;"></i>
                                Build Report
                            </button>
                            <button class="btn primary" onclick="exportCheckoutReport()" id="exportCheckoutBtn" style="margin-left: 10px; display: none;">
                                <i data-lucide="download" style="width: 16px; height: 16px;"></i>
                                Export Report
                            </button>
                        </div>
                    </div>

                    <!-- Equipment Review Section -->
                    <div id="checkoutEquipmentSection" style="display: none; margin-top: 20px;">
                        <div class="summary-card">
                            <h3 style="margin-bottom: 15px;">Equipment & Templates Review</h3>
                            <p style="opacity: 0.8; margin-bottom: 15px;">Review equipment detected. Uncheck items that should not be included in the report.</p>
                            <div id="checkoutEquipmentList"></div>
                        </div>
                    </div>

                    <!-- Report Preview -->
                    <div id="checkoutReportPreview" style="display: none; margin-top: 20px;"></div>
                </div>
            </div>

            <div id="detailPanel" class="detail-panel"></div>
        </div>
    </div>
    
    <div id="toast" class="toast"></div>

    <!-- Help Modal -->
    <div id="helpModal" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 900px; height: 85vh;">
            <div class="modal-header">
                <h2>Niagara Sidekick Help</h2>
                <button class="modal-close" onclick="closeHelpModal()">&times;</button>
            </div>
            <div style="display: flex; height: calc(100% - 72px);">
                <!-- Left Navigation -->
                <div class="help-nav">
                    <div class="help-nav-section">VIEWS</div>
                    <div class="help-nav-item active" onclick="showHelpSection('station-tree')">Tree View</div>
                    <div class="help-nav-item" onclick="showHelpSection('station-templates')">Templates</div>
                    <div class="help-nav-item" onclick="showHelpSection('station-comparison')">Comparison</div>
                </div>

                <!-- Right Content -->
                <div class="help-content" id="helpContent">
                    <!-- Content will be dynamically loaded here -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let appData = null;
        let compareData = null;
        let currentView = 'tree';
        let comparisonActive = false;
        let graphicsData = null; // { folderName, pxFiles: [], results: [] }
        let graphicsMappingData = null; // Map(viewName -> equipmentPath)

        // File handling
        function openFile() {
            document.getElementById('fileInput').click();
        }

        function copyBqlQuery() {
            const query = "station:|slot:/Drivers|bql:select slotPath, type as 'Point Type', facets from control:ControlPoint";
            navigator.clipboard.writeText(query).then(() => {
                showToast('BQL query copied to clipboard!', 'success');
            }).catch(err => {
                console.error('Failed to copy:', err);
                showToast('Failed to copy query', 'error');
            });
        }
        
        async function loadFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            document.getElementById('fileName').textContent = file.name;

            try {
                const csvContent = await loadCSV(file);
                appData = processCSV(csvContent);
                updateDisplay();
                showToast('File loaded successfully');

                // Show compare button after first file is loaded
                document.getElementById('compareBogBtn').style.display = 'inline-flex';

                // Auto-save after loading file
                saveToLocalStorage();
            } catch (error) {
                console.error('Error:', error);
                showToast('Error loading file');
            }
        }

        function openCompareFile() {
            document.getElementById('compareFileInput').click();
        }

        async function loadCompareFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            document.getElementById('compareFileName').textContent = file.name;

            try {
                const csvContent = await loadCSV(file);
                compareData = processCSV(csvContent);
                comparisonActive = true;

                // Show comparison UI elements
                document.getElementById('compareFileInfo').style.display = 'block';
                document.getElementById('clearComparisonBtn').style.display = 'inline-flex';
                document.getElementById('comparisonBtn').style.display = 'inline-flex';

                updateDisplay();
                showToast('Comparison file loaded successfully');

                // Auto-save after loading comparison file
                saveToLocalStorage();
            } catch (error) {
                console.error('Error:', error);
                showToast('Error loading comparison file');
            }
        }

        function clearComparison() {
            compareData = null;
            comparisonActive = false;

            // Hide comparison UI elements
            document.getElementById('compareFileInfo').style.display = 'none';
            document.getElementById('clearComparisonBtn').style.display = 'none';
            document.getElementById('comparisonBtn').style.display = 'none';

            // Clear file input
            document.getElementById('compareFileInput').value = '';

            updateDisplay();
            showToast('Comparison cleared');
        }

        // Live connection functions
        async function loadCSV(file) {
            if (!file.name.endsWith('.csv')) {
                throw new Error('Please upload a CSV file');
            }
            return await file.text();
        }

        // Helper function to extract simple point type from full type string
        function extractSimpleType(fullType) {
            if (!fullType) return 'Unknown';

            // Extract type from formats like "control:BooleanPoint", "control:NumericWritable", etc.
            const match = fullType.match(/:(\w+)/);
            if (!match) return 'Unknown';

            const pointType = match[1];

            // Simplify to base types
            if (pointType.includes('Boolean')) return 'Boolean';
            if (pointType.includes('Numeric')) return 'Numeric';
            if (pointType.includes('Enum')) return 'Enum';
            if (pointType.includes('String')) return 'String';

            return 'Unknown';
        }

        // Helper function to generate colored circle icon for point types
        function generatePointTypeIcon(pointType) {
            let bgColor = '#9E9E9E'; // Grey default
            let letter = '?';

            if (pointType === 'Boolean') {
                bgColor = '#4CAF50'; // Green
                letter = 'B';
            } else if (pointType === 'Numeric') {
                bgColor = '#9C27B0'; // Purple
                letter = 'N';
            } else if (pointType === 'Enum') {
                bgColor = '#FFC107'; // Yellow
                letter = 'E';
            } else if (pointType === 'String') {
                bgColor = '#9E9E9E'; // Grey
                letter = 'S';
            }

            return `<span style="background: ${bgColor}; color: white; border-radius: 50%; width: 14px; height: 14px; display: inline-flex; align-items: center; justify-content: center; font-size: 9px; font-weight: bold; margin-right: 4px; flex-shrink: 0;">${letter}</span>`;
        }

        function processCSV(csvContent) {
            const lines = csvContent.split('\n').filter(line => line.trim());
            if (lines.length === 0) {
                throw new Error('Empty CSV file');
            }

            // Parse CSV - assume first line is header
            const header = lines[0].split(',');
            const objectIndex = header.findIndex(col => {
                const colLower = col.toLowerCase();
                return colLower.includes('object') || colLower.includes('slot path') || (colLower.includes('slot') && colLower.includes('path'));
            });

            if (objectIndex === -1) {
                throw new Error('No Object or Slot Path column found in CSV');
            }

            // Check for Facets column (optional)
            const facetsIndex = header.findIndex(col => col.toLowerCase().includes('facet'));
            const hasFacets = facetsIndex !== -1;

            // Check for Point Type column (optional)
            const pointTypeIndex = header.findIndex(col => {
                const colLower = col.toLowerCase();
                return colLower.includes('point type') || colLower.includes('type');
            });
            const hasPointType = pointTypeIndex !== -1;

            // Step 1: Build path tree and collect all paths
            const pathTree = {};
            const allPaths = new Set();
            const pointPaths = new Set();
            const facetsMap = new Map(); // Map<pointPath, facetsString>
            const pointTypesMap = new Map(); // Map<pointPath, pointType>

            // Process each CSV row (skip header)
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                const cols = line.split(',');
                let pointPath = cols[objectIndex]?.trim();

                if (!pointPath || !pointPath.startsWith('slot:/Drivers/')) continue;

                // Store the original path with slot: prefix
                const originalPath = pointPath;

                // Remove slot: prefix for tree building (it's a namespace indicator, not part of hierarchy)
                pointPath = pointPath.replace(/^slot:/, '');

                allPaths.add(pointPath);
                pointPaths.add(pointPath);

                // Store facets data if column exists
                if (hasFacets) {
                    const facetsData = cols[facetsIndex]?.trim();
                    if (facetsData) {
                        facetsMap.set(pointPath, facetsData);
                    }
                }

                // Store point type data if column exists
                if (hasPointType) {
                    const pointTypeData = cols[pointTypeIndex]?.trim();
                    if (pointTypeData) {
                        pointTypesMap.set(pointPath, pointTypeData);
                    }
                }

                // Build tree structure
                const segments = pointPath.split('/').filter(s => s);
                let currentNode = pathTree;
                let currentPath = '';

                segments.forEach((segment, index) => {
                    currentPath += '/' + segment;

                    if (!currentNode[segment]) {
                        currentNode[segment] = {
                            name: segment,
                            path: currentPath,
                            children: {},
                            isPoint: false,
                            points: [],
                            isEquipment: false
                        };
                    }

                    // Mark as point if it's the final segment
                    if (index === segments.length - 1) {
                        currentNode[segment].isPoint = true;
                    }

                    allPaths.add(currentPath);
                    currentNode = currentNode[segment].children;
                });
            }

            console.log('Built path tree with', allPaths.size, 'total paths and', pointPaths.size, 'point paths');

            // Step 2: Identify equipment by working backwards from each point
            const equipmentMap = new Map();
            const points = new Map();

            pointPaths.forEach(pointPath => {
                const segments = pointPath.split('/').filter(s => s);
                const pointName = segments.pop(); // Remove the point name

                // Determine equipment by working backwards
                let equipmentPath;
                let equipmentName;

                if (segments.length > 0 && segments[segments.length - 1] === 'points') {
                    // If parent is "points", equipment is one level up
                    segments.pop(); // Remove "points"
                    if (segments.length > 0) {
                        equipmentName = segments[segments.length - 1];
                        equipmentPath = '/' + segments.join('/');
                    } else {
                        // Edge case: if we have /points/pointName, skip it
                        return;
                    }
                } else {
                    // Otherwise, parent folder is the equipment
                    if (segments.length > 0) {
                        equipmentName = segments[segments.length - 1];
                        equipmentPath = '/' + segments.join('/');
                    } else {
                        // Edge case: point at root level, skip it
                        return;
                    }
                }

                // Create equipment if it doesn't exist
                if (!equipmentMap.has(equipmentPath)) {
                    equipmentMap.set(equipmentPath, {
                        name: equipmentName,
                        path: equipmentPath,
                        points: [],
                        hasPointsFolder: pointPath.includes('/points/')
                    });
                }

                // Create point object
                const point = {
                    name: pointName,
                    path: pointPath,
                    type: extractSimpleType(pointTypesMap.get(pointPath)),
                    hasPointsFolder: pointPath.includes('/points/'),
                    equipmentPath: equipmentPath
                };

                // Add point to maps
                points.set(pointPath, point);
                equipmentMap.get(equipmentPath).points.push(point);
            });

            console.log('Found', equipmentMap.size, 'equipment and', points.size, 'points');

            // Add equipment paths to allPaths for tree building
            equipmentMap.forEach((equipment, equipmentPath) => {
                allPaths.add(equipmentPath);
                // Also add intermediate paths
                const segments = equipmentPath.split('/').filter(s => s);
                let buildPath = '';
                segments.forEach(segment => {
                    buildPath += '/' + segment;
                    allPaths.add(buildPath);
                });
            });

            // Convert to arrays and sort
            const devices = Array.from(equipmentMap.values());
            devices.forEach(device => {
                device.points.sort((a, b) => a.name.localeCompare(b.name));
            });

            // Find templates
            const templates = findTemplates(devices);

            // Detect driver types from CSV paths
            const driverTypes = new Set();
            allPaths.forEach(path => {
                const driverMatch = path.match(/\/Drivers\/([^\/]+)/);
                if (driverMatch) {
                    driverTypes.add(driverMatch[1]);
                }
            });

            const detectedDrivers = Array.from(driverTypes);
            let primaryDriver = 'BacnetNetwork';
            if (detectedDrivers.includes('BacnetNetwork')) {
                primaryDriver = 'BacnetNetwork';
            } else if (detectedDrivers.includes('ModbusNetwork')) {
                primaryDriver = 'ModbusNetwork';
            } else if (detectedDrivers.includes('LonNetwork')) {
                primaryDriver = 'LonNetwork';
            } else if (detectedDrivers.length > 0) {
                primaryDriver = detectedDrivers[0];
            }

            // Update global detectedConfig
            window.detectedConfig = {
                driverType: primaryDriver,
                stationPrefix: 'station:',
                detectedDrivers: detectedDrivers
            };

            // Build tree
            const tree = buildTree(Array.from(allPaths), devices);

            console.log('CSV Processing Results:', {
                devices: devices.length,
                points: points.size,
                templates: templates.exact.length,
                facets: facetsMap.size,
                pointTypes: pointTypesMap.size
            });

            return { devices, points, templates, tree, paths: Array.from(allPaths), facetsMap, pointTypesMap, detectedConfig: window.detectedConfig };
        }

        function findTemplates(devices) {
            const exact = [];
            const used = new Set();
            
            devices.forEach(device => {
                if (used.has(device.name)) return;
                
                const template = {
                    points: device.points,
                    devices: [device]
                };
                
                used.add(device.name);
                
                devices.forEach(other => {
                    if (used.has(other.name)) return;
                    if (device.points.length !== other.points.length) return;
                    
                    const match = device.points.every((p, i) => 
                        p.name === other.points[i].name
                    );
                    
                    if (match) {
                        template.devices.push(other);
                        used.add(other.name);
                    }
                });
                
                exact.push(template);
            });
            
            // Find partials
            const partial = [];
            exact.forEach((t1, i) => {
                exact.forEach((t2, j) => {
                    if (i >= j) return;
                    
                    const matching = t1.points.filter(p1 => 
                        t2.points.some(p2 => p1.name === p2.name)
                    ).length;
                    
                    const total = Math.max(t1.points.length, t2.points.length);
                    const percent = Math.round((matching / total) * 100);
                    
                    if (percent >= 80 && percent < 100) {
                        partial.push({ t1, t2, percent, matching, total });
                    }
                });
            });
            
            return { exact, partial };
        }
        
        function buildTree(paths, devices) {
            const root = { name: 'Station', children: [] };
            
            paths.forEach(path => {
                // Include all paths for complete tree structure - don't skip nested paths
                
                const parts = path.split('/').filter(p => p);
                let current = root;
                
                parts.forEach(part => {
                    let child = current.children.find(c => c.name === part);
                    if (!child) {
                        child = { name: part, children: [] };
                        current.children.push(child);
                    }
                    current = child;
                });
            });
            
            // Mark folders with equipment using new generic detection
            function markHasEquipment(node, path = '') {
                const currentPath = path ? `${path}/${node.name}` : `/${node.name}`;
                let hasEquipment = false;

                // Check if this node is equipment (found in our equipment map)
                const device = devices.find(d => d.path === currentPath);
                if (device) {
                    hasEquipment = true;
                    node.isDirectDevice = true;
                }

                // Check all children recursively
                node.children.forEach(child => {
                    if (markHasEquipment(child, currentPath)) {
                        hasEquipment = true;
                    }
                });

                // Set the flag on this node
                if (hasEquipment) {
                    node.hasEquipment = true;
                }

                return hasEquipment;
            }
            
            markHasEquipment(root);
            
            return root;
        }
        
        // Display functions
        function updateDisplay() {
            if (!appData) {
                // Reset counters to 0 when no data
                document.getElementById('deviceCount').textContent = '0';
                document.getElementById('pointCount').textContent = '0';
                document.getElementById('templateCount').textContent = '0';
                document.getElementById('partialCount').textContent = '0';

                // Disable graphics buttons when no CSV loaded
                const graphicsBtn = document.getElementById('graphicsBtn');
                const selectFolderBtn = document.getElementById('selectFolderBtn');
                const graphicsFolderInput = document.getElementById('graphicsFolderInput');
                const selectMappingBtn = document.getElementById('selectMappingBtn');
                const graphicsMappingInput = document.getElementById('graphicsMappingInput');
                if (graphicsBtn) {
                    graphicsBtn.disabled = true;
                    graphicsBtn.title = 'Load a CSV file first';
                }
                if (selectFolderBtn) {
                    selectFolderBtn.classList.add('disabled');
                    selectFolderBtn.title = 'Load a CSV file first';
                }
                if (graphicsFolderInput) {
                    graphicsFolderInput.disabled = true;
                }
                if (selectMappingBtn) {
                    selectMappingBtn.classList.add('disabled');
                    selectMappingBtn.title = 'Load a CSV file first';
                }
                if (graphicsMappingInput) {
                    graphicsMappingInput.disabled = true;
                }
                return;
            }

            // Update stats (excluding excluded items)
            const nonExcludedDevices = appData.devices.filter(device => !excludedItems.has(device.path));

            // Handle both Map and array/object for points
            let pointsArray = [];
            if (appData.points && typeof appData.points.values === 'function') {
                pointsArray = Array.from(appData.points.values());
            } else if (appData.points && Array.isArray(appData.points)) {
                pointsArray = appData.points;
            }
            const nonExcludedPoints = pointsArray.filter(point => point.path && !excludedItems.has(point.path));

            document.getElementById('deviceCount').textContent = nonExcludedDevices.length;
            document.getElementById('pointCount').textContent = nonExcludedPoints.length;
            document.getElementById('templateCount').textContent = appData.templates.exact.length;
            document.getElementById('partialCount').textContent = appData.templates.partial.length;

            // Enable graphics buttons when CSV is loaded
            const graphicsBtn = document.getElementById('graphicsBtn');
            const selectFolderBtn = document.getElementById('selectFolderBtn');
            const graphicsFolderInput = document.getElementById('graphicsFolderInput');
            const selectMappingBtn = document.getElementById('selectMappingBtn');
            const graphicsMappingInput = document.getElementById('graphicsMappingInput');
            if (graphicsBtn) {
                graphicsBtn.disabled = false;
                graphicsBtn.title = '';
            }
            if (selectFolderBtn) {
                selectFolderBtn.classList.remove('disabled');
                selectFolderBtn.title = '';
            }
            if (graphicsFolderInput) {
                graphicsFolderInput.disabled = false;
            }
            if (selectMappingBtn) {
                selectMappingBtn.classList.remove('disabled');
                selectMappingBtn.title = '';
            }
            if (graphicsMappingInput) {
                graphicsMappingInput.disabled = false;
            }

            // Update detected drivers display
            updateDetectedDriversDisplay();

            // Update views
            updateTree();
            updateTemplates();

            // Update comparison if active
            if (comparisonActive) {
                updateComparison();
            }
        }
        
        function updateTree() {
            const container = document.getElementById('treeView');
            container.innerHTML = '';

            const drivers = appData.tree.children.find(c => c.name === 'Drivers');
            if (drivers) {
                renderNode(drivers, container, 0, '');
            }

            // Refresh Lucide icons after rendering tree
            lucide.createIcons();
        }
        
        function renderNode(node, container, level, path) {
            const currentPath = path ? `${path}/${node.name}` : `/${node.name}`;
            const isPoints = node.name === 'points';
            const device = appData.devices.find(d => d.path === currentPath);
            const hasChildren = Object.keys(node.children).length > 0;

            // Check if this node is a point (any leaf node that isn't a "points" folder)
            const isActualPoint = !hasChildren && !isPoints;

            const item = document.createElement('div');
            item.className = 'tree-item';

            // Mark equipment for styling but don't change behavior
            if (device) {
                item.classList.add('device');
            }

            // Check if this item is excluded
            const isExcluded = excludedItems.has(currentPath);
            if (isExcluded) {
                item.classList.add('excluded');
            }

            item.style.paddingLeft = `${level * 20}px`;

            // Create the tree item content with expand button if has children
            let itemContent = '';

            if (hasChildren) {
                itemContent += `<span class="expand-btn" data-path="${currentPath}"><i data-lucide="chevron-right" style="width: 14px; height: 14px;"></i></span>`;
            } else {
                itemContent += `<span class="expand-spacer"></span>`;
            }
            
            // Determine icon based on node type
            let icon = '<i data-lucide="folder" style="width: 14px; height: 14px;"></i>'; // Default folder icon
            if (isPoints) {
                icon = '<i data-lucide="folder" style="width: 14px; height: 14px;"></i>';
            } else if (device) {
                icon = '<i data-lucide="cpu" style="width: 14px; height: 14px;"></i>';
            } else if (node.isPoint || isActualPoint) {
                // Get point type and create colored circle icon
                const pointData = appData.points.get(currentPath);
                const pointType = pointData?.type || 'Unknown';

                let bgColor = '#9E9E9E'; // Grey default
                let letter = '?';

                if (pointType === 'Boolean') {
                    bgColor = '#4CAF50'; // Green
                    letter = 'B';
                } else if (pointType === 'Numeric') {
                    bgColor = '#9C27B0'; // Purple
                    letter = 'N';
                } else if (pointType === 'Enum') {
                    bgColor = '#FFC107'; // Yellow
                    letter = 'E';
                } else if (pointType === 'String') {
                    bgColor = '#9E9E9E'; // Grey
                    letter = 'S';
                }

                icon = `<span style="background: ${bgColor}; color: white; border-radius: 50%; width: 16px; height: 16px; display: inline-flex; align-items: center; justify-content: center; font-size: 10px; font-weight: bold; flex-shrink: 0;">${letter}</span>`;
            }

            // Add checkbox for equipment/devices only
            if (device) {
                const currentDevicePath = device.path;
                const isChecked = checkedItems.has(currentDevicePath);
                itemContent += `<input type="checkbox" class="device-checkbox" data-path="${currentDevicePath.replace(/"/g, '&quot;')}"
                               onclick="toggleDeviceCheck(event, this.dataset.path)" ${isChecked ? 'checked' : ''}>`;
            }

            // Add icon and node name
            if (node.isPoint || isActualPoint) {
                itemContent += `<span class="node-icon">${icon}</span><span class="node-name point">${node.name}</span>`;
                item.className += ' point';
            } else if (device) {
                itemContent += `<span class="node-icon">${icon}</span><span class="node-name"><strong>${node.name}</strong></span>`;
            } else {
                itemContent += `<span class="node-icon">${icon}</span><span class="node-name">${node.name}</span>`;
            }

            // Add toggle exclude button for containers and equipment (not individual points)
            if (!isActualPoint) {
                const buttonIcon = isExcluded ? '<i data-lucide="eye" style="width: 14px; height: 14px;"></i>' : '<i data-lucide="eye-off" style="width: 14px; height: 14px;"></i>';
                const buttonTitle = isExcluded ? `Include ${node.name}` : `Exclude ${node.name}`;
                itemContent += `<button class="delete-btn" onclick="toggleExcludeNode('${currentPath}', '${node.name.replace(/'/g, "\\'")}'); event.stopPropagation();" title="${buttonTitle}">${buttonIcon}</button>`;
            }

            item.innerHTML = itemContent;

            // Add click handler for node selection
            item.onclick = (e) => {
                // Don't select if clicking expand button, checkbox, or delete button
                if (e.target.classList.contains('expand-btn') || e.target.classList.contains('device-checkbox') || e.target.classList.contains('delete-btn')) {
                    return;
                }

                // Remove previous selection
                document.querySelectorAll('.tree-item.selected').forEach(el =>
                    el.classList.remove('selected'));

                // Select this item
                item.classList.add('selected');

                // Show details if this is equipment
                if (device) {
                    showDeviceDetail(currentPath);
                } else if (node.isPoint || isActualPoint) {
                    // For points, copy ORD
                    copyORD({name: node.name, path: currentPath});
                }
            };

            container.appendChild(item);

            // Create child container if node has children
            if (hasChildren) {
                const childContainer = document.createElement('div');
                childContainer.className = 'tree-children';
                container.appendChild(childContainer);

                // Add expand button handler
                const expandBtn = item.querySelector('.expand-btn');

                expandBtn.onclick = (e) => {
                    e.stopPropagation();
                    const isOpen = childContainer.classList.contains('open');
                    const icon = expandBtn.querySelector('i');
                    if (isOpen) {
                        childContainer.classList.remove('open');
                        icon.setAttribute('data-lucide', 'chevron-right');
                    } else {
                        childContainer.classList.add('open');
                        icon.setAttribute('data-lucide', 'chevron-down');
                    }
                    lucide.createIcons(); // Refresh the icon
                };
                // Render all children
                Object.values(node.children).forEach(child => {
                    renderNode(child, childContainer, level + 1, currentPath);
                });
            }
        }
        
        function updateTemplates() {
            const container = document.getElementById('templatesView');
            const sorted = [...appData.templates.exact].sort((a, b) => b.devices.length - a.devices.length);
            
            let html = `
                <div class="summary-card">
                    <h2>Templates Report</h2>
                    <div class="summary-stats">
                        <div class="stat">
                            <div class="stat-value">${sorted.length}</div>
                            <div class="stat-label">Unique Templates</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value">${appData.devices.length}</div>
                            <div class="stat-label">Total Devices</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value">${(appData.devices.length / sorted.length).toFixed(1)}</div>
                            <div class="stat-label">Avg per Template</div>
                        </div>
                    </div>
                </div>
            `;
            
            sorted.forEach((t, i) => {
                const originalIndex = appData.templates.exact.indexOf(t);
                const percent = ((t.devices.length / appData.devices.length) * 100).toFixed(1);

                html += `
                    <div class="template-card">
                        <div class="template-header">
                            <span class="template-title">Template ${originalIndex + 1}</span>
                            <span class="template-count">${t.devices.length} devices (${percent}%)</span>
                        </div>
                        <div class="template-controls">
                            <button class="template-control-btn check-all" onclick="checkAllInTemplate(${i})">✓ All</button>
                            <button class="template-control-btn uncheck-all" onclick="uncheckAllInTemplate(${i})">✗ All</button>
                        </div>
                        <div class="device-grid">
                            ${t.devices.map(d => {
                                const isChecked = checkedItems.has(d.path);
                                return `<div class="device-item" title="${d.ord || d.path}">
                                    <input type="checkbox" class="template-device-checkbox" data-path="${d.path.replace(/"/g, '&quot;')}"
                                           onclick="toggleDeviceCheck(event, this.dataset.path)" ${isChecked ? 'checked' : ''}>
                                    ${d.name}
                                </div>`;
                            }).join('')}
                        </div>
                        <div class="points-summary">
                            <div class="points-header">
                                <strong>${t.points.length} Points:</strong>
                                ${t.points.length > 8 ? `<button class="expand-points-btn" data-template="${i}" onclick="togglePoints(${i})">▶</button>` : ''}
                            </div>
                            <div class="points-preview" id="points-preview-${i}">
                                ${t.points.slice(0, 8).map(p => p.name).join(', ')}
                                ${t.points.length > 8 ? '...' : ''}
                            </div>
                            <div class="points-expanded" id="points-expanded-${i}" style="display: none;">
                                ${t.points.map(p =>
                                    `<div class="template-point-item" onclick="copyORD({name:'${p.name}', path:'${p.path}'})" title="Click to copy ORD" style="display: flex; align-items: center;">${generatePointTypeIcon(p.type || 'Unknown')}${p.name}</div>`
                                ).join('')}
                            </div>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }

        function togglePoints(templateIndex) {
            const previewEl = document.getElementById(`points-preview-${templateIndex}`);
            const expandedEl = document.getElementById(`points-expanded-${templateIndex}`);
            const buttonEl = document.querySelector(`[data-template="${templateIndex}"]`);

            if (expandedEl.style.display === 'none') {
                // Expand
                previewEl.style.display = 'none';
                expandedEl.style.display = 'grid';
                buttonEl.textContent = '▼';
            } else {
                // Collapse
                previewEl.style.display = 'block';
                expandedEl.style.display = 'none';
                buttonEl.textContent = '▶';
            }
        }

        function generateComparisonReport() {
            if (!appData || !compareData) return;

            const primary = appData.devices;
            const secondary = compareData.devices;

            // Create device maps for easy lookup
            const primaryMap = new Map(primary.map(d => [d.path, d]));
            const secondaryMap = new Map(secondary.map(d => [d.path, d]));

            // Find differences
            const onlyInPrimary = primary.filter(d => !secondaryMap.has(d.path));
            const onlyInSecondary = secondary.filter(d => !primaryMap.has(d.path));
            const inBoth = primary.filter(d => secondaryMap.has(d.path));

            // Analyze point differences for common equipment
            const pointDifferences = [];
            inBoth.forEach(primaryDevice => {
                const secondaryDevice = secondaryMap.get(primaryDevice.path);
                const primaryPoints = new Set(primaryDevice.points.map(p => p.name));
                const secondaryPoints = new Set(secondaryDevice.points.map(p => p.name));

                const missingInSecondary = primaryDevice.points.filter(p => !secondaryPoints.has(p.name));
                const missingInPrimary = secondaryDevice.points.filter(p => !primaryPoints.has(p.name));

                if (missingInSecondary.length > 0 || missingInPrimary.length > 0) {
                    pointDifferences.push({
                        device: primaryDevice,
                        missingInSecondary,
                        missingInPrimary
                    });
                }
            });

            return {
                onlyInPrimary,
                onlyInSecondary,
                inBoth,
                pointDifferences,
                primaryName: document.getElementById('fileName').textContent,
                secondaryName: document.getElementById('compareFileName').textContent
            };
        }

        function updateComparison() {
            const container = document.getElementById('comparisonView');
            const comparison = generateComparisonReport();

            if (!comparison) {
                container.innerHTML = '<p>No comparison data available</p>';
                return;
            }

            let html = `
                <div class="summary-card">
                    <h2>CSV Comparison Report</h2>
                    <div style="margin-top: 15px; font-size: 14px;">
                        <div><strong>Primary:</strong> ${comparison.primaryName}</div>
                        <div><strong>Compare:</strong> ${comparison.secondaryName}</div>
                    </div>
                    <div class="summary-stats">
                        <div class="stat">
                            <div class="stat-value">${comparison.onlyInPrimary.length}</div>
                            <div class="stat-label">Only in Primary</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value">${comparison.onlyInSecondary.length}</div>
                            <div class="stat-label">Only in Compare</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value">${comparison.inBoth.length}</div>
                            <div class="stat-label">In Both</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value">${comparison.pointDifferences.length}</div>
                            <div class="stat-label">Point Differences</div>
                        </div>
                    </div>
                </div>
            `;

            // Only in Primary
            if (comparison.onlyInPrimary.length > 0) {
                html += `
                    <div class="template-card">
                        <div class="template-header">
                            <span class="template-title">Equipment Only in Primary</span>
                            <span class="template-count">${comparison.onlyInPrimary.length} devices</span>
                        </div>
                        <div class="device-grid">
                            ${comparison.onlyInPrimary.map(d => `<div class="device-item" style="border-left-color: #e74c3c;">${d.name} (${d.points.length} points)</div>`).join('')}
                        </div>
                    </div>
                `;
            }

            // Only in Secondary
            if (comparison.onlyInSecondary.length > 0) {
                html += `
                    <div class="template-card">
                        <div class="template-header">
                            <span class="template-title">Equipment Only in Compare</span>
                            <span class="template-count">${comparison.onlyInSecondary.length} devices</span>
                        </div>
                        <div class="device-grid">
                            ${comparison.onlyInSecondary.map(d => `<div class="device-item" style="border-left-color: #27ae60;">${d.name} (${d.points.length} points)</div>`).join('')}
                        </div>
                    </div>
                `;
            }

            // Point Differences
            if (comparison.pointDifferences.length > 0) {
                html += `
                    <div class="template-card">
                        <div class="template-header">
                            <span class="template-title">Equipment with Point Differences</span>
                            <span class="template-count">${comparison.pointDifferences.length} devices</span>
                        </div>
                `;

                comparison.pointDifferences.forEach(diff => {
                    html += `
                        <div style="margin: 16px 0; padding: 12px; background: #f8f9fa; border-radius: 6px; border-left: 4px solid #f39c12;">
                            <div style="font-weight: 600; margin-bottom: 8px;">${diff.device.name}</div>

                            ${diff.missingInSecondary.length > 0 ? `
                                <div style="margin: 8px 0;">
                                    <div style="font-size: 12px; font-weight: 500; color: #e74c3c; margin-bottom: 4px;">
                                        Missing in Compare (${diff.missingInSecondary.length}):
                                    </div>
                                    <div style="font-size: 11px; color: #666;">
                                        ${diff.missingInSecondary.map(p => p.name).join(', ')}
                                    </div>
                                </div>
                            ` : ''}

                            ${diff.missingInPrimary.length > 0 ? `
                                <div style="margin: 8px 0;">
                                    <div style="font-size: 12px; font-weight: 500; color: #27ae60; margin-bottom: 4px;">
                                        Missing in Primary (${diff.missingInPrimary.length}):
                                    </div>
                                    <div style="font-size: 11px; color: #666;">
                                        ${diff.missingInPrimary.map(p => p.name).join(', ')}
                                    </div>
                                </div>
                            ` : ''}
                        </div>
                    `;
                });

                html += `</div>`;
            }

            container.innerHTML = html;
        }
        
        // ORD Translation Engine
        class ORDTranslator {
            constructor(config = {}) {
                this.driverType = config.driverType || 'BacnetNetwork';
                this.stationPrefix = config.stationPrefix || 'station:';
                this.serverUrl = config.serverUrl || '{server}';
            }

            translate(csvPath, pointName = null) {
                const clean = this.cleanPath(csvPath);
                const isPoint = pointName !== null;
                const fullPath = isPoint ? `${clean}/points/${pointName}` : clean;

                return {
                    csvPath: csvPath,
                    cleanPath: clean,
                    ord: this.toORD(fullPath),
                    obixPath: this.toObixPath(fullPath),
                    obixValueUrl: this.toObixValueUrl(fullPath),
                    foxUrl: this.toFoxUrl(fullPath),
                    isPoint: isPoint
                };
            }

            cleanPath(path) {
                // Remove common extensions
                let clean = path.replace(/\/(HistoryExt|NumericInterval|AlarmExt|StatusExt)$/, '');

                // Decode URL encoding
                clean = decodeURIComponent(clean);
                clean = clean.replace(/%5/g, '/').replace(/%20/g, ' ');

                // Strip prefixes
                clean = clean.replace(/^\/Eureka/, '');
                clean = clean.replace(/^\/slot/, '');
                clean = clean.replace(/^\/config/, '');

                // Handle $ encoding
                clean = clean.replace(/\$2d/g, '-');
                clean = clean.replace(/\$20/g, ' ');
                clean = clean.replace(/\$2f/g, '/');
                clean = clean.replace(/\$2c/g, ',');
                clean = clean.replace(/\$2e/g, '.');
                clean = clean.replace(/\$3a/g, ':');

                return clean;
            }

            toORD(path) {
                // Multiple pattern support
                if (path.startsWith('/devices/')) {
                    return `${this.stationPrefix}|slot:/Drivers/${this.driverType}${path.substring(8)}`;
                }
                if (path.includes('/Drivers/')) {
                    // Check if path already has slot: prefix to avoid duplication
                    const slotPath = path.startsWith('slot:') ? path : `slot:${path}`;
                    return `${this.stationPrefix}|${slotPath}`;
                }
                return `${this.stationPrefix}|slot:/Config${path}`;
            }

            toObixPath(path) {
                const ord = this.toORD(path);
                return ord.replace(`${this.stationPrefix}|slot:`, '/obix/config');
            }

            toObixValueUrl(path) {
                const obixPath = this.toObixPath(path);
                return `${obixPath}/out/value`;
            }

            toFoxUrl(path) {
                const ord = this.toORD(path);
                return ord.replace(`${this.stationPrefix}|slot:`, `fox://${this.stationPrefix.replace(':', '')}`);
            }
        }

        // Global ORD translator instance
        let ordTranslator = new ORDTranslator();
        let detectedConfig = {
            driverType: 'BacnetNetwork',
            stationPrefix: 'station:',
            detectedDrivers: []
        };

        // Auto-detect driver types from CSV content

        // JSON Export functionality
        function generateFullExport() {
            if (!appData) {
                showToast('No data to export');
                return;
            }

            const exportData = {
                metadata: {
                    exportVersion: "2.0",
                    exportDate: new Date().toISOString(),
                    sourceFile: document.getElementById('fileName').textContent,
                    stationInfo: {
                        detectedFormat: "auto-detected",
                        driverType: detectedConfig.driverType,
                        detectedDrivers: detectedConfig.detectedDrivers,
                        pointCount: appData.points.size,
                        equipmentCount: appData.devices.length
                    }
                },
                hierarchy: generateHierarchy(),
                templates: generateTemplatesExport(),
                apiConfig: {
                    recommended: "obix",
                    endpoints: {
                        obix: `${document.getElementById('serverUrl')?.value || '{server}'}/obix`,
                        fox: `${document.getElementById('serverUrl')?.value || '{server}'}:4911`,
                        rest: `${document.getElementById('serverUrl')?.value || '{server}'}/api`
                    }
                }
            };

            return exportData;
        }

        function generateHierarchy() {
            const systems = new Map();

            appData.devices.forEach(device => {
                const pathParts = device.path.split('/').filter(p => p);

                // Extract system info from path
                const systemName = pathParts.length >= 3 ? pathParts[2] : 'Unknown';

                if (!systems.has(systemName)) {
                    systems.set(systemName, {
                        name: systemName,
                        path: `/${pathParts.slice(0, 3).join('/')}`,
                        equipment: []
                    });
                }

                // Generate equipment entry with all translation formats
                const deviceTranslation = ordTranslator.translate(device.path);

                const equipmentEntry = {
                    id: device.name.toLowerCase().replace(/[^a-z0-9]/g, '_'),
                    name: device.name,
                    displayName: device.name,
                    type: detectEquipmentType(device.name),
                    template: findTemplateId(device),
                    paths: {
                        csv: device.path,
                        ord: deviceTranslation.ord,
                        obix: deviceTranslation.obixPath,
                        fox: deviceTranslation.foxUrl
                    },
                    points: device.points.map(point => {
                        const pointTranslation = ordTranslator.translate(device.path, point.name);
                        return {
                            id: `${device.name.toLowerCase().replace(/[^a-z0-9]/g, '_')}_${point.name.toLowerCase().replace(/[^a-z0-9]/g, '_')}`,
                            name: point.name,
                            displayName: point.name,
                            paths: {
                                csv: point.path,
                                ord: pointTranslation.ord,
                                obix: pointTranslation.obixPath,
                                obixValue: pointTranslation.obixValueUrl
                            },
                            metadata: {
                                unit: detectUnit(point.name),
                                precision: 1,
                                writable: detectWritable(point.name)
                            }
                        };
                    })
                };

                systems.get(systemName).equipment.push(equipmentEntry);
            });

            return {
                building: "Station",
                systems: Array.from(systems.values())
            };
        }

        function generateTemplatesExport() {
            return appData.templates.exact.map((template, index) => ({
                id: `template_${index + 1}`,
                name: `Template ${index + 1}`,
                pointSignatures: template.points.map(p => p.name),
                instanceCount: template.devices.length,
                instances: template.devices.map(d => d.name)
            }));
        }

        function detectEquipmentType(name) {
            const name_lower = name.toLowerCase();
            if (name_lower.includes('ahu')) return 'AHU';
            if (name_lower.includes('vav')) return 'VAV';
            if (name_lower.includes('chiller')) return 'Chiller';
            if (name_lower.includes('boiler')) return 'Boiler';
            if (name_lower.includes('pump')) return 'Pump';
            if (name_lower.includes('fan')) return 'Fan';
            return 'Generic';
        }

        function detectUnit(pointName) {
            const name_lower = pointName.toLowerCase();
            if (name_lower.includes('temp')) return '°F';
            if (name_lower.includes('pressure')) return 'PSI';
            if (name_lower.includes('humidity')) return '%RH';
            if (name_lower.includes('flow')) return 'CFM';
            if (name_lower.includes('position') || name_lower.includes('damper')) return '%';
            return '';
        }

        function detectWritable(pointName) {
            const name_lower = pointName.toLowerCase();
            return name_lower.includes('setpoint') ||
                   name_lower.includes('command') ||
                   name_lower.includes('override') ||
                   name_lower.includes('position');
        }

        function findTemplateId(device) {
            const templateIndex = appData.templates.exact.findIndex(t =>
                t.devices.some(d => d.path === device.path)
            );
            return templateIndex >= 0 ? `template_${templateIndex + 1}` : null;
        }

        function downloadJSON() {
            const exportData = generateFullExport();
            const json = JSON.stringify(exportData, null, 2);

            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `niagara_export_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showToast('JSON export downloaded');
        }

        function copyJSONToClipboard() {
            const exportData = generateFullExport();
            const json = JSON.stringify(exportData, null, 2);

            const textarea = document.createElement('textarea');
            textarea.value = json;
            textarea.style.position = 'absolute';
            textarea.style.left = '-9999px';
            document.body.appendChild(textarea);
            textarea.select();

            try {
                document.execCommand('copy');
                showToast('JSON copied to clipboard');
            } catch (err) {
                showToast('Copy failed');
            }

            document.body.removeChild(textarea);
        }



        function updateServerUrl() {
            const serverUrl = document.getElementById('serverUrl').value;

            // Update the ORD translator with new server URL but keep detected config
            ordTranslator = new ORDTranslator({
                driverType: detectedConfig.driverType,
                stationPrefix: detectedConfig.stationPrefix,
                serverUrl: serverUrl
            });

            // Auto-save after updating server URL
            saveToLocalStorage();
        }

        function updateDetectedDriversDisplay() {
            const displayElement = document.getElementById('detectedDrivers');
            if (!displayElement) return; // Element removed from UI

            if (detectedConfig.detectedDrivers.length > 0) {
                displayElement.textContent = detectedConfig.detectedDrivers.join(', ');
                displayElement.style.color = 'var(--success-color)';
            } else {
                displayElement.textContent = 'None detected';
                displayElement.style.color = 'var(--text-muted)';
            }
        }

        // Interaction functions
        function copyORD(point) {
            // Generate relativized ORD for use in Niagara graphics
            let relativizedORD;

            // Check for FCU points first (e.g., /VRF_System/points/FCU1_1/ac_StartStopStatus_1)
            if (point.path.includes('/points/') && /\/points\/FCU\d+_\d+\//.test(point.path)) {
                // FCU devices: points are directly under the FCU unit
                // e.g., /VRF_System/points/FCU1_1/ac_StartStopStatus_1 → slot:ac_StartStopStatus_1
                relativizedORD = `slot:${point.name}`;
            } else {
                // Determine the device this point belongs to
                let devicePath;
                if (point.parentDevicePath) {
                    // For nested points like RTU1_Points, use parent device
                    devicePath = point.parentDevicePath;
                } else if (point.path.includes('/points/')) {
                    devicePath = point.path.split('/points/')[0];
                } else {
                    devicePath = point.path.substring(0, point.path.lastIndexOf('/'));
                }

                // Find the device to understand its structure
                const device = appData.devices.find(d => d.path === devicePath);

                if (device && device.isVRFUnit) {
                    // VRF FCU devices: points are directly under the device
                    // e.g., /VRF_System/points/FCU1_1/ac_StartStopStatus_1 → slot:ac_StartStopStatus_1
                    relativizedORD = `slot:${point.name}`;
                } else if (point.pointFolder) {
                    // Point is in a nested folder like RTU1_Points
                    // e.g., /RTU$2d1/points/RTU1_Points/Alarm$20Status → slot:points/RTU1_Points/Alarm$20Status
                    relativizedORD = `slot:points/${point.pointFolder}/${point.name}`;
                } else if (point.hasPointsFolder || point.path.includes('/points/')) {
                    // Point is in a standard points folder
                    // e.g., /DOAS$2d1/points/pointName → slot:points/pointName
                    relativizedORD = `slot:points/${point.name}`;
                } else {
                    // Point is directly under the equipment (rare case)
                    relativizedORD = `slot:${point.name}`;
                }
            }

            // Create textarea, select, copy, remove
            const textarea = document.createElement('textarea');
            textarea.value = relativizedORD;
            textarea.style.position = 'absolute';
            textarea.style.left = '-9999px';
            document.body.appendChild(textarea);
            textarea.select();

            try {
                document.execCommand('copy');
                showToast(`Copied: ${relativizedORD}`);
            } catch (err) {
                showToast('Copy failed');
            }

            document.body.removeChild(textarea);
        }

        // Helper function for copying points from detail panel
        function copyPointFromDetail(pointName, hasPointsFolder, devicePath, pointFolder = '') {
            const point = {
                name: pointName,
                hasPointsFolder: hasPointsFolder,
                pointFolder: pointFolder || null,
                path: hasPointsFolder ? `${devicePath}/points/${pointName}` : `${devicePath}/${pointName}`
            };
            copyORD(point);
        }
        
        function showDeviceDetail(path) {
            const device = appData.devices.find(d => d.path === path);
            if (!device) return;
            
            const template = appData.templates.exact.find(t => 
                t.devices.some(d => d.path === path)
            );
            
            const partials = appData.templates.partial.filter(p => 
                p.t1 === template || p.t2 === template
            );
            
            let html = `
                <div class="detail-header">
                    <h3><i data-lucide="cpu" style="width: 18px; height: 18px;"></i> ${device.name}</h3>
                    <div style="font-size: 12px; opacity: 0.9;">${device.path}</div>
                </div>
            `;
            
            if (template) {
                const idx = appData.templates.exact.indexOf(template) + 1;
                html += `
                    <div class="detail-section">
                        <h4>Template ${idx}</h4>
                        <div>${template.devices.length} devices (click to navigate):</div>
                        ${template.devices.map(d => 
                            `<div class="device-link ${d.path === path ? 'current' : ''}" 
                                 onclick="showDeviceDetail('${d.path}')"
                                 style="background: ${d.path === path ? '#4db864' : 'var(--sidebar-color)'}; 
                                        color: ${d.path === path ? 'white' : 'inherit'};">
                                ${d.name}
                            </div>`
                        ).join('')}
                    </div>
                    
                    <div class="detail-section">
                        <h4>Points (${template.points.length}) - Click to copy</h4>
                        ${template.points.map(p =>
                            `<div class="detail-point"
                                  onclick="copyPointFromDetail('${p.name.replace(/'/g, "\\'")}', ${p.hasPointsFolder}, '${device.path}', '${(p.pointFolder || '').replace(/'/g, "\\'")}')"
                                  title="Click to copy: slot:${device.isVRFUnit ? '' : (p.hasPointsFolder ? (p.pointFolder ? `points/${p.pointFolder}/` : 'points/') : '')}${p.name}">
                                ${generatePointTypeIcon(p.type || 'Unknown')}${p.name}
                            </div>`
                        ).join('')}
                    </div>
                `;
                
                if (partials.length > 0) {
                    html += `
                        <div class="detail-section">
                            <h4>Partial Matches</h4>
                            ${partials.map(p => {
                                const other = p.t1 === template ? p.t2 : p.t1;
                                const otherIdx = appData.templates.exact.indexOf(other) + 1;
                                
                                // Find differences
                                const mainPoints = template.points;
                                const otherPoints = other.points;
                                
                                const missing = mainPoints.filter(mp => 
                                    !otherPoints.some(op => op.name === mp.name)
                                );
                                
                                const extra = otherPoints.filter(op => 
                                    !mainPoints.some(mp => mp.name === op.name)
                                );
                                
                                return `
                                    <div style="padding: 8px; margin: 8px 0; background: white; border-radius: 4px; border: 1px solid #dee2e6;">
                                        <div style="font-weight: bold; color: #2c3e50;">Template ${otherIdx}: ${p.percent}% match</div>
                                        <div style="font-size: 11px; color: #6c757d; margin: 4px 0;">${p.matching} of ${p.total} points match</div>
                                        
                                        <div style="margin-top: 8px; font-size: 11px; color: #6c757d;">
                                            <strong>Devices (${other.devices.length}):</strong>
                                            ${other.devices.slice(0, 3).map(d => d.name).join(', ')}${other.devices.length > 3 ? '...' : ''}
                                        </div>
                                        
                                        ${missing.length > 0 ? `
                                            <div style="margin-top: 8px;">
                                                <div style="font-size: 11px; font-weight: bold; color: #c62828;">Missing from Template ${otherIdx}:</div>
                                                ${missing.map(m => 
                                                    `<div class="diff-point missing">• ${m.name}</div>`
                                                ).join('')}
                                            </div>
                                        ` : ''}
                                        
                                        ${extra.length > 0 ? `
                                            <div style="margin-top: 8px;">
                                                <div style="font-size: 11px; font-weight: bold; color: #2e7d32;">Extra in Template ${otherIdx}:</div>
                                                ${extra.map(e => 
                                                    `<div class="diff-point extra">• ${e.name}</div>`
                                                ).join('')}
                                            </div>
                                        ` : ''}
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    `;
                }
            }
            
            document.getElementById('detailPanel').innerHTML = html;
            document.getElementById('detailPanel').classList.add('show');

            // Refresh Lucide icons in detail panel
            lucide.createIcons();
        }
        
        function showView(view) {
            currentView = view;

            // Clear search when switching views
            const searchInput = document.getElementById('treeSearchInput');
            if (searchInput && searchInput.value) {
                clearSearch();
            }

            // Update sub-tab active state
            document.querySelectorAll('.sub-tab').forEach(btn => {
                btn.classList.remove('active');
            });
            if (event && event.currentTarget) {
                event.currentTarget.classList.add('active');
            }

            // Hide all views first
            document.getElementById('treeView').style.display = 'none';
            document.getElementById('templatesView').style.display = 'none';
            document.getElementById('comparisonView').style.display = 'none';

            // Hide tree controls by default
            document.getElementById('treeControls').classList.remove('active');

            // Show selected view
            if (view === 'tree') {
                document.getElementById('treeView').style.display = 'block';
                // Show tree controls only for tree view
                document.getElementById('treeControls').classList.add('active');
            } else if (view === 'templates') {
                document.getElementById('templatesView').style.display = 'block';
                closeDetail();
            } else if (view === 'comparison') {
                document.getElementById('comparisonView').style.display = 'block';
                closeDetail();
                if (comparisonActive) {
                    updateComparison();
                }
            }
        }

        function expandAll() {
            document.querySelectorAll('.tree-children').forEach(el => {
                el.classList.add('open');
            });
        }
        
        function collapseAll() {
            document.querySelectorAll('.tree-children').forEach(el => {
                el.classList.remove('open');
            });
        }
        
        function closeDetail() {
            document.getElementById('detailPanel').classList.remove('show');
        }

        function filterTree(query) {
            const searchInput = document.getElementById('treeSearchInput');
            const clearBtn = document.getElementById('clearSearchBtn');

            // Show/hide clear button
            if (query.trim()) {
                clearBtn.style.display = 'block';
            } else {
                clearBtn.style.display = 'none';
            }

            if (!query.trim()) {
                // Show all items if search is empty
                if (currentView === 'templates') {
                    // Show all template cards and devices
                    document.querySelectorAll('.template-card').forEach(card => {
                        card.style.display = '';
                    });
                    document.querySelectorAll('.device-item').forEach(item => {
                        item.style.display = '';
                    });
                } else {
                    // Show all tree items
                    document.querySelectorAll('.tree-item').forEach(item => {
                        item.style.display = '';
                        item.classList.remove('search-match');
                    });
                    document.querySelectorAll('.tree-children').forEach(container => {
                        container.style.display = '';
                    });
                }
                return;
            }

            const searchLower = query.toLowerCase();

            // Handle templates view differently
            if (currentView === 'templates') {
                const templateCards = document.querySelectorAll('.template-card');

                templateCards.forEach(card => {
                    const deviceItems = card.querySelectorAll('.device-item');
                    let hasMatch = false;

                    // Check each device in the template
                    deviceItems.forEach(item => {
                        const text = item.textContent.toLowerCase();
                        if (text.includes(searchLower)) {
                            item.style.display = '';
                            hasMatch = true;
                        } else {
                            item.style.display = 'none';
                        }
                    });

                    // Show template card if any device matches
                    if (hasMatch) {
                        card.style.display = '';
                    } else {
                        card.style.display = 'none';
                    }
                });
            } else {
                // Tree view filtering (original logic)
                const treeItems = document.querySelectorAll('.tree-item');

                // First pass: mark matching items
                treeItems.forEach(item => {
                    const nodeName = item.querySelector('.node-name');
                    if (nodeName) {
                        const text = nodeName.textContent.toLowerCase();
                        if (text.includes(searchLower)) {
                            item.classList.add('search-match');
                            item.style.display = '';
                        } else {
                            item.classList.remove('search-match');
                            item.style.display = 'none';
                        }
                    }
                });

                // Second pass: show parents of matching items
                document.querySelectorAll('.tree-item.search-match').forEach(matchedItem => {
                    let parent = matchedItem.parentElement;
                    while (parent) {
                        if (parent.classList.contains('tree-children')) {
                            parent.style.display = '';
                            parent.classList.add('open');
                            const prevItem = parent.previousElementSibling;
                            if (prevItem && prevItem.classList.contains('tree-item')) {
                                prevItem.style.display = '';
                            }
                        }
                        parent = parent.parentElement;
                    }
                });

                // Refresh Lucide icons for any updated expand buttons
                lucide.createIcons();
            }
        }

        function clearSearch() {
            const searchInput = document.getElementById('treeSearchInput');
            searchInput.value = '';
            filterTree('');
        }

        // Logo typing animation
        let logoAnimationTimer = null;
        const shortText = '[nsk]';
        const fullText = '[niagarasidekick]';

        function typeLogoText() {
            // Clear any existing animation
            if (logoAnimationTimer) {
                clearTimeout(logoAnimationTimer);
                logoAnimationTimer = null;
            }

            const logoEl = document.getElementById('logoText');
            let currentIndex = shortText.length;

            function typeNextChar() {
                if (currentIndex <= fullText.length) {
                    logoEl.textContent = fullText.substring(0, currentIndex);
                    currentIndex++;
                    logoAnimationTimer = setTimeout(typeNextChar, 40);
                }
            }

            typeNextChar();
        }

        function resetLogoText() {
            // Clear any existing animation
            if (logoAnimationTimer) {
                clearTimeout(logoAnimationTimer);
                logoAnimationTimer = null;
            }

            const logoEl = document.getElementById('logoText');
            let currentIndex = fullText.length;

            function deleteNextChar() {
                if (currentIndex >= shortText.length) {
                    logoEl.textContent = fullText.substring(0, currentIndex);
                    currentIndex--;
                    logoAnimationTimer = setTimeout(deleteNextChar, 30);
                } else {
                    // Ensure we end at exactly the short text
                    logoEl.textContent = shortText;
                }
            }

            deleteNextChar();
        }

        function showToast(message, type = 'info', duration = 3000) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = 'toast show'; // Reset classes

            // Add type-specific class for styling
            if (type === 'error') {
                toast.classList.add('error');
            } else if (type === 'success') {
                toast.classList.add('success');
            } else if (type === 'warning') {
                toast.classList.add('warning');
            }

            setTimeout(() => {
                toast.classList.remove('show');
            }, duration);
        }

        console.log('Niagara Navigator - CSV Point Explorer');

        // === CHECKBOX FUNCTIONALITY ===
        let checkedItems = new Set(); // Track checked equipment/devices
        let excludedItems = new Set(); // Track excluded equipment/devices

        function toggleDeviceCheck(event, path) {
            event.stopPropagation();
            if (checkedItems.has(path)) {
                checkedItems.delete(path);
            } else {
                checkedItems.add(path);
            }
            updateCheckboxDisplay();
            updateCheckedCounter();
            saveToLocalStorage();
        }

        function checkAllInTemplate(templateIndex) {
            const template = [...appData.templates.exact].sort((a, b) => b.devices.length - a.devices.length)[templateIndex];
            template.devices.forEach(device => {
                checkedItems.add(device.path);
            });
            updateCheckboxDisplay();
            updateCheckedCounter();
            saveToLocalStorage();
        }

        function uncheckAllInTemplate(templateIndex) {
            const template = [...appData.templates.exact].sort((a, b) => b.devices.length - a.devices.length)[templateIndex];
            template.devices.forEach(device => {
                checkedItems.delete(device.path);
            });
            updateCheckboxDisplay();
            updateCheckedCounter();
            saveToLocalStorage();
        }

        function checkAllDevices() {
            if (!appData || !appData.devices) return;

            appData.devices.forEach(device => {
                checkedItems.add(device.path);
            });

            updateCheckboxDisplay();
            updateCheckedCounter();
            saveToLocalStorage();
        }

        function uncheckAllDevices() {
            checkedItems.clear();
            updateCheckboxDisplay();
            updateCheckedCounter();
            saveToLocalStorage();
        }

        // Delete functionality
        function toggleExcludeNode(nodePath, nodeName) {
            // Prevent exclusion of critical root nodes
            if (nodePath === '/Drivers' || nodePath === 'Drivers') {
                showToast('Cannot exclude the Drivers root node', 'error');
                return;
            }

            const isCurrentlyExcluded = excludedItems.has(nodePath);
            const action = isCurrentlyExcluded ? 'Include' : 'Exclude';

            // Count affected items for confirmation
            const affectedItems = countAffectedItems(nodePath);

            const confirmMessage = `${action} "${nodeName}" and all its children?\n\nThis will ${action.toLowerCase()}:\n- ${affectedItems.devices} device(s)\n- ${affectedItems.points} point(s)\n\nFrom templates and counts.`;

            if (!confirm(confirmMessage)) {
                return;
            }

            if (isCurrentlyExcluded) {
                // Include the item and all its children
                includeItemRecursively(nodePath);
            } else {
                // Exclude the item and all its children
                excludeItemRecursively(nodePath);
                // Remove from checked items when excluding
                clearCheckedItemsForPath(nodePath);
            }

            // Rebuild templates
            rebuildTemplates();

            // Update all displays
            updateDisplay();
            updateTree();
            updateTemplates();
            updateCheckboxDisplay();
            updateCheckedCounter();

            // Close detail panel if showing excluded device
            const detailPanel = document.getElementById('detailPanel');
            if (detailPanel && detailPanel.classList.contains('show')) {
                detailPanel.classList.remove('show');
            }

            // Save to localStorage
            saveToLocalStorage();

            const statusMessage = isCurrentlyExcluded ? 'Included' : 'Excluded';
            showToast(`${statusMessage} "${nodeName}" and ${affectedItems.devices + affectedItems.points} associated items`, 'success');
        }

        function excludeItemRecursively(nodePath) {
            // Add the main path
            excludedItems.add(nodePath);

            // Add all devices that start with this path
            appData.devices.forEach(device => {
                if (device.path.startsWith(nodePath) || device.path === nodePath) {
                    excludedItems.add(device.path);
                }
            });

            // Add all points that start with this path
            if (appData.points) {
                if (typeof appData.points.forEach === 'function') {
                    appData.points.forEach(point => {
                        if (point.path && (point.path.startsWith(nodePath) || point.path === nodePath)) {
                            excludedItems.add(point.path);
                        }
                    });
                } else if (typeof appData.points.values === 'function') {
                    Array.from(appData.points.values()).forEach(point => {
                        if (point.path && (point.path.startsWith(nodePath) || point.path === nodePath)) {
                            excludedItems.add(point.path);
                        }
                    });
                }
            }
        }

        function includeItemRecursively(nodePath) {
            // Remove the main path
            excludedItems.delete(nodePath);

            // Remove all devices that start with this path
            appData.devices.forEach(device => {
                if (device.path.startsWith(nodePath) || device.path === nodePath) {
                    excludedItems.delete(device.path);
                }
            });

            // Remove all points that start with this path
            if (appData.points) {
                if (typeof appData.points.forEach === 'function') {
                    appData.points.forEach(point => {
                        if (point.path && (point.path.startsWith(nodePath) || point.path === nodePath)) {
                            excludedItems.delete(point.path);
                        }
                    });
                } else if (typeof appData.points.values === 'function') {
                    Array.from(appData.points.values()).forEach(point => {
                        if (point.path && (point.path.startsWith(nodePath) || point.path === nodePath)) {
                            excludedItems.delete(point.path);
                        }
                    });
                }
            }
        }

        function countAffectedItems(nodePath) {
            let devices = 0;
            let points = 0;

            // Count affected devices
            appData.devices.forEach(device => {
                if (device.path.startsWith(nodePath) || device.path === nodePath) {
                    devices++;
                }
            });

            // Count affected points
            if (appData.points) {
                if (typeof appData.points.forEach === 'function') {
                    appData.points.forEach(point => {
                        if (point.path && (point.path.startsWith(nodePath) || point.path === nodePath)) {
                            points++;
                        }
                    });
                } else if (typeof appData.points.values === 'function') {
                    Array.from(appData.points.values()).forEach(point => {
                        if (point.path && (point.path.startsWith(nodePath) || point.path === nodePath)) {
                            points++;
                        }
                    });
                }
            }

            return { devices, points };
        }

        function clearCheckedItemsForPath(nodePath) {
            const itemsToRemove = [];
            checkedItems.forEach(item => {
                if (item.startsWith(nodePath) || item === nodePath) {
                    itemsToRemove.push(item);
                }
            });
            itemsToRemove.forEach(item => checkedItems.delete(item));
        }


        function rebuildTemplates() {
            if (!appData.devices || appData.devices.length === 0) {
                appData.templates = { exact: [], partial: [] };
                return;
            }

            // Filter out excluded devices before building templates
            const nonExcludedDevices = appData.devices.filter(device => !excludedItems.has(device.path));

            if (nonExcludedDevices.length === 0) {
                appData.templates = { exact: [], partial: [] };
                return;
            }

            // Rebuild templates using the existing findTemplates function with non-excluded devices
            const newTemplates = findTemplates(nonExcludedDevices);
            appData.templates = {
                exact: newTemplates.exact,
                partial: newTemplates.partial
            };
        }

        function updateCheckboxDisplay() {
            // Update tree view checkboxes
            document.querySelectorAll('.device-checkbox').forEach(checkbox => {
                const path = checkbox.dataset.path;
                checkbox.checked = checkedItems.has(path);

                // Update tree item visual state
                const treeItem = checkbox.closest('.tree-item');
                if (treeItem) {
                    if (checkedItems.has(path)) {
                        treeItem.classList.add('device-checked');
                    } else {
                        treeItem.classList.remove('device-checked');
                    }
                }
            });

            // Update template view checkboxes
            document.querySelectorAll('.template-device-checkbox').forEach(checkbox => {
                const path = checkbox.dataset.path;
                checkbox.checked = checkedItems.has(path);
            });
        }

        function updateCheckedCounter() {
            // Update any checked counter displays if they exist
            const counter = document.getElementById('checkedCounter');
            if (counter) {
                counter.textContent = `${checkedItems.size} checked`;
            }
        }

        function loadCheckboxesFromLocalStorage() {
            const saved = localStorage.getItem('niagaraNavigatorCheckedItems');
            if (saved) {
                checkedItems = new Set(JSON.parse(saved));
                updateCheckboxDisplay();
                updateCheckedCounter();
            }

            const savedExcluded = localStorage.getItem('niagaraNavigatorExcludedItems');
            if (savedExcluded) {
                excludedItems = new Set(JSON.parse(savedExcluded));
            }
        }

        // === REFLOW BUILDER FUNCTIONALITY ===
        let selectedReflowTemplate = null;
        let selectedReflowPartialMatches = new Set();
        let reflowListenersSetup = false;

        function initializeReflowBuilder() {
            populateReflowTemplateDropdown();
            setupReflowEventListeners();
        }

        function populateReflowTemplateDropdown() {
            const select = document.getElementById('reflowTemplateSelect');
            const sorted = [...appData.templates.exact].sort((a, b) => b.devices.length - a.devices.length);

            // Clear existing options except the first one
            select.innerHTML = '<option value="">Choose a template...</option>';

            sorted.forEach((template, index) => {
                const option = document.createElement('option');
                option.value = index;
                // Use original template number (consistent with Templates tab)
                const originalTemplateNumber = appData.templates.exact.indexOf(template) + 1;
                option.textContent = `Template ${originalTemplateNumber} (${template.devices.length} devices, ${template.points.length} points)`;
                select.appendChild(option);
            });
        }

        function setupReflowEventListeners() {
            if (reflowListenersSetup) return; // Prevent duplicate listeners

            const templateSelect = document.getElementById('reflowTemplateSelect');
            const reflowTitle = document.getElementById('reflowTitle');
            const exportReflowCSVBtn = document.getElementById('exportReflowCSVBtn');
            const exportReflowEquipmentBtn = document.getElementById('exportReflowEquipmentBtn');

            templateSelect.addEventListener('change', onReflowTemplateSelected);
            reflowTitle.addEventListener('input', function() {
                updateReflowExportButtons();
                saveToLocalStorage();
            });
            exportReflowCSVBtn.addEventListener('click', exportReflowCSV);
            exportReflowEquipmentBtn.addEventListener('click', exportReflowEquipmentCSV);

            reflowListenersSetup = true;
        }

        function onReflowTemplateSelected() {
            const select = document.getElementById('reflowTemplateSelect');
            const templateIndex = parseInt(select.value);

            // Clear any previously selected partial matches
            selectedReflowPartialMatches.clear();

            if (isNaN(templateIndex)) {
                selectedReflowTemplate = null;
                document.getElementById('reflowTemplatePreview').style.display = 'none';
                document.getElementById('reflowPartialMatchesSection').style.display = 'none';
                updateReflowExportButtons();
                return;
            }

            const sorted = [...appData.templates.exact].sort((a, b) => b.devices.length - a.devices.length);
            selectedReflowTemplate = sorted[templateIndex];

            displayReflowTemplatePreview();
            displayReflowPartialMatches();
            updateReflowExportButtons();
        }

        function displayReflowTemplatePreview() {
            const preview = document.getElementById('reflowTemplatePreview');
            const pointsContainer = document.getElementById('reflowTemplatePoints');

            if (!selectedReflowTemplate) {
                preview.style.display = 'none';
                return;
            }

            preview.style.display = 'block';
            pointsContainer.innerHTML = selectedReflowTemplate.points
                .map(p => `<div class="point-item">${p.name}</div>`)
                .join('');
        }

        function displayReflowPartialMatches() {
            const section = document.getElementById('reflowPartialMatchesSection');
            const container = document.getElementById('reflowPartialMatches');

            if (!selectedReflowTemplate) {
                section.style.display = 'none';
                return;
            }

            const partials = appData.templates.partial.filter(p =>
                p.t1 === selectedReflowTemplate || p.t2 === selectedReflowTemplate
            );

            if (partials.length === 0) {
                section.style.display = 'none';
                return;
            }

            let html = '';

            partials.forEach((partial, index) => {
                const otherTemplate = partial.t1 === selectedReflowTemplate ? partial.t2 : partial.t1;
                const matchId = `reflow_partial_${index}`;

                // Find the template number for this partial match (consistent with Templates tab)
                const templateNumber = appData.templates.exact.indexOf(otherTemplate) + 1;

                html += `
                    <div class="partial-match-item">
                        <div class="partial-match-info">
                            <div>
                                <strong>Template ${templateNumber} with ${otherTemplate.devices.length} devices</strong>
                                <span class="partial-match-similarity">(${partial.percent}% match)</span>
                            </div>
                            <div style="font-size: 12px; color: var(--text-secondary);">
                                ${partial.matching}/${partial.total} points match
                            </div>
                        </div>
                        <label style="display: flex; align-items: center; gap: 8px; margin-top: 10px;">
                            <input type="checkbox" id="${matchId}" onchange="onReflowPartialMatchToggle(${index})">
                            Include additional unique points from this template
                        </label>
                    </div>
                `;
            });

            container.innerHTML = html;
            section.style.display = 'block';
        }

        function onReflowPartialMatchToggle(partialIndex) {
            const checkbox = document.getElementById(`reflow_partial_${partialIndex}`);

            if (checkbox.checked) {
                selectedReflowPartialMatches.add(partialIndex);
            } else {
                selectedReflowPartialMatches.delete(partialIndex);
            }

            updateReflowExportButtons();
        }

        function updateReflowExportButtons() {
            const exportReflowCSVBtn = document.getElementById('exportReflowCSVBtn');
            const exportReflowEquipmentBtn = document.getElementById('exportReflowEquipmentBtn');
            const reflowTitle = document.getElementById('reflowTitle').value.trim();

            const shouldEnable = selectedReflowTemplate && reflowTitle;
            exportReflowCSVBtn.disabled = !shouldEnable;
            exportReflowEquipmentBtn.disabled = !shouldEnable;
        }

        function getReflowPoints() {
            if (!selectedReflowTemplate) return [];

            // Start with all points from selected base template
            const allPoints = [...selectedReflowTemplate.points];
            console.log(`Base template points: ${allPoints.map(p => p.name).join(', ')}`);

            // Add only NEW points from selected partial matches (no duplicates)
            const partials = appData.templates.partial.filter(p =>
                p.t1 === selectedReflowTemplate || p.t2 === selectedReflowTemplate
            );

            selectedReflowPartialMatches.forEach(partialIndex => {
                const partial = partials[partialIndex];
                const otherTemplate = partial.t1 === selectedReflowTemplate ? partial.t2 : partial.t1;
                console.log(`Adding from partial template with ${otherTemplate.points.length} points`);

                // Only add points that don't already exist in the base template
                otherTemplate.points.forEach(point => {
                    if (!allPoints.some(existing => existing.name === point.name)) {
                        console.log(`Adding new point: ${point.name}`);
                        allPoints.push(point);
                    } else {
                        console.log(`Skipping duplicate point: ${point.name}`);
                    }
                });
            });

            // Sort points alphabetically
            allPoints.sort((a, b) => a.name.localeCompare(b.name));

            console.log(`Final unique points (${allPoints.length}): ${allPoints.map(p => p.name).join(', ')}`);
            return allPoints;
        }

        function exportReflowCSV() {
            if (!selectedReflowTemplate) return;

            const reflowTitle = document.getElementById('reflowTitle').value.trim();

            if (!reflowTitle) return;

            const allPoints = getReflowPoints();
            const csv = generateReflowCSV(allPoints);
            downloadReflowCSV(csv, `${reflowTitle}.csv`);
        }

        function exportReflowEquipmentCSV() {
            if (!selectedReflowTemplate) return;

            const reflowTitle = document.getElementById('reflowTitle').value.trim();

            if (!reflowTitle) return;

            const csv = generateReflowEquipmentCSV();
            downloadReflowCSV(csv, `${reflowTitle}_equipment.csv`);
        }

        function generateReflowCSV(points) {
            let csv = 'Display Name,Niagara Point,Group,Featured,Hidden\n';

            points.forEach(point => {
                // Display Name: blank, Niagara Point: point name, Group: blank, Featured: false, Hidden: false
                csv += `,${point.name},,false,false\n`;
            });

            return csv;
        }

        function generateReflowEquipmentCSV() {
            // Extract unique equipment from the selected templates
            const equipmentSet = new Set();

            // Add equipment from base template
            if (selectedReflowTemplate && selectedReflowTemplate.devices) {
                selectedReflowTemplate.devices.forEach(device => {
                    equipmentSet.add(device.name);
                });
            }

            // Add equipment from partial matches
            const partials = appData.templates.partial.filter(p =>
                p.t1 === selectedReflowTemplate || p.t2 === selectedReflowTemplate
            );

            selectedReflowPartialMatches.forEach(partialIndex => {
                const partial = partials[partialIndex];
                const otherTemplate = partial.t1 === selectedReflowTemplate ? partial.t2 : partial.t1;

                if (otherTemplate && otherTemplate.devices) {
                    otherTemplate.devices.forEach(device => {
                        equipmentSet.add(device.name);
                    });
                }
            });

            // Convert to sorted array and generate CSV
            const equipmentList = Array.from(equipmentSet).sort();

            let csv = 'Equipment Name\n';
            equipmentList.forEach(equipment => {
                csv += `${equipment}\n`;
            });

            return csv;
        }

        function downloadReflowCSV(csvContent, filename) {
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showToast(`Exported ${filename} successfully!`);
        }

        // === REFLOW REGEX GEN FUNCTIONALITY ===
        let regexPointNames = ['dat', 'disch air temp', 'discharge air temperature'];
        let regexGeneratedPattern = '';
        let regexImportedPattern = '';

        function initializeReflowRegex() {
            updateRegexPointInputs();
            generateRegexPattern();
        }

        function updateRegexPointInputs() {
            const container = document.getElementById('regexPointInputs');
            if (!container) return;

            container.innerHTML = '';

            regexPointNames.forEach((name, index) => {
                const div = document.createElement('div');
                div.className = 'regex-point-input-row';

                const input = document.createElement('input');
                input.type = 'text';
                input.value = name;
                input.placeholder = 'Enter point name variation...';
                input.className = 'regex-point-input';
                input.addEventListener('input', (e) => {
                    regexPointNames[index] = e.target.value;
                    generateRegexPattern();
                });

                const button = document.createElement('button');
                button.className = 'regex-remove-btn';
                button.style.display = regexPointNames.length > 1 ? 'block' : 'none';
                button.innerHTML = '✕';
                button.onclick = () => {
                    regexPointNames.splice(index, 1);
                    updateRegexPointInputs();
                    generateRegexPattern();
                };

                div.appendChild(input);
                div.appendChild(button);
                container.appendChild(div);
            });
        }

        function addRegexPointInput() {
            regexPointNames.push('');
            updateRegexPointInputs();
            generateRegexPattern();
        }

        function escapeRegexSpecialChars(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        function parseImportedRegexPattern(regexString) {
            if (!regexString.trim()) return null;

            try {
                // Remove forward slashes if present
                let cleanRegex = regexString.trim();
                if (cleanRegex.startsWith('/') && cleanRegex.endsWith('/')) {
                    cleanRegex = cleanRegex.slice(1, -1);
                }

                // Test if the regex is valid
                new RegExp(cleanRegex, 'i');

                return cleanRegex;
            } catch (error) {
                return null;
            }
        }

        function toggleRegexImport() {
            const content = document.getElementById('regexImportContent');
            const icon = document.getElementById('regexImportToggleIcon');

            if (content.classList.contains('expanded')) {
                content.classList.remove('expanded');
                icon.textContent = '▼';
            } else {
                content.classList.add('expanded');
                icon.textContent = '▲';
            }
        }

        function clearRegexImport() {
            const input = document.getElementById('regexExistingInput');
            const status = document.getElementById('regexImportStatus');

            input.value = '';
            regexImportedPattern = '';
            status.style.display = 'none';
            generateRegexPattern();
        }

        function showRegexImportStatus(message, isError = false) {
            const status = document.getElementById('regexImportStatus');
            status.className = 'regex-import-status ' + (isError ? 'error' : 'success');
            status.innerHTML = `${isError ? '✕' : '✓'} ${message}`;
            status.style.display = 'flex';

            if (!isError) {
                setTimeout(() => {
                    status.style.display = 'none';
                }, 3000);
            }
        }

        function generateRegexPattern() {
            const cleanNames = regexPointNames
                .filter(name => name.trim())
                .map(name => name.toLowerCase().trim());

            // Handle case with only imported regex and no variations
            if (cleanNames.length === 0 && regexImportedPattern) {
                regexGeneratedPattern = `/${regexImportedPattern}/`;
                updateRegexOutput();
                return;
            }

            if (cleanNames.length === 0 && !regexImportedPattern) {
                regexGeneratedPattern = '';
                updateRegexOutput();
                return;
            }

            let newPattern = '';

            if (cleanNames.length === 1) {
                const name = cleanNames[0];
                const words = name.split(/[\s_]+/).filter(word => word);
                newPattern = words
                    .map(word => escapeRegexSpecialChars(word) + '[a-z]*')
                    .join('[\\s_]*');
            } else {
                const allWords = cleanNames.flatMap(name =>
                    name.split(/[\s_]+/).filter(word => word)
                );
                const uniqueWords = [...new Set(allWords)];

                // Filter common words to avoid overly broad patterns
                const commonWords = uniqueWords.filter(word => {
                    // Only consider words that are at least 2 characters long
                    if (word.length < 2) return false;

                    // Check if word appears in all names
                    return cleanNames.every(name => name.includes(word));
                });

                // Calculate pattern specificity to avoid overly broad matches
                const calculateSpecificity = (words) => {
                    return words.reduce((score, word) => score + word.length, 0);
                };

                if (commonWords.length > 0 && calculateSpecificity(commonWords) >= 6) {
                    // Only use common words if they provide sufficient specificity
                    const sortedCommon = commonWords.sort((a, b) => {
                        const orderMap = {
                            discharge: 1,
                            disch: 1,
                            da: 1,
                            supply: 2,
                            return: 3,
                            air: 4,
                            temp: 5,
                            temperature: 5,
                        };
                        return (orderMap[a] || 99) - (orderMap[b] || 99);
                    });

                    newPattern = sortedCommon
                        .map(word => escapeRegexSpecialChars(word) + '[a-z]*')
                        .join('[\\s_]*');
                } else {
                    // Fall back to alternation pattern for better specificity
                    const patterns = cleanNames.map(name => {
                        const words = name
                            .split(/[\s_]+/)
                            .filter(word => word.length > 0);

                        // Ensure minimum pattern complexity
                        if (words.length === 1 && words[0].length < 3) {
                            return escapeRegexSpecialChars(words[0]);
                        }

                        return words
                            .map(word => escapeRegexSpecialChars(word) + '[a-z]*')
                            .join('[\\s_]*');
                    });
                    newPattern = `(${patterns.join('|')})`;
                }
            }

            // Combine imported regex with new pattern
            if (regexImportedPattern && newPattern) {
                regexGeneratedPattern = `/(${regexImportedPattern}|${newPattern})/`;
            } else if (regexImportedPattern) {
                regexGeneratedPattern = `/${regexImportedPattern}/`;
            } else {
                regexGeneratedPattern = `/${newPattern}/`;
            }

            updateRegexOutput();
            testRegexPattern();
        }

        function updateRegexOutput() {
            const output = document.getElementById('regexOutput');
            const copyBtn = document.getElementById('regexCopyBtn');

            if (!output) return;

            if (regexGeneratedPattern) {
                output.textContent = regexGeneratedPattern;
                output.classList.remove('regex-output-placeholder');
                if (copyBtn) copyBtn.style.display = 'block';
            } else {
                output.textContent = 'Enter point names to generate regex...';
                output.classList.add('regex-output-placeholder');
                if (copyBtn) copyBtn.style.display = 'none';
            }
        }

        function copyRegexToClipboard() {
            navigator.clipboard.writeText(regexGeneratedPattern)
                .then(() => {
                    const success = document.getElementById('regexCopySuccess');
                    if (success) {
                        success.style.display = 'flex';
                        setTimeout(() => {
                            success.style.display = 'none';
                        }, 2000);
                    }
                })
                .catch(err => {
                    console.error('Failed to copy text: ', err);
                });
        }

        function testRegexPattern() {
            const testInput = document.getElementById('regexTestInput');
            const testResults = document.getElementById('regexTestResults');

            if (!testInput || !testResults) return;

            if (!regexGeneratedPattern || !testInput.value.trim()) {
                testResults.innerHTML = '<p style="color: var(--text-muted); font-size: 13px;">Enter test strings to see results...</p>';
                return;
            }

            try {
                const pattern = regexGeneratedPattern.slice(1, -1);
                const regex = new RegExp(pattern, 'i');

                const testStrings = testInput.value
                    .split('\n')
                    .filter(str => str.trim());

                const results = testStrings.map(str => ({
                    input: str.trim(),
                    matches: regex.test(str.toLowerCase().trim())
                }));

                testResults.innerHTML = results
                    .map(result => `
                        <div class="regex-test-result-item ${result.matches ? 'match' : 'no-match'}">
                            <span class="regex-test-icon">${result.matches ? '✓' : '○'}</span>
                            <span>${result.input}</span>
                        </div>
                    `)
                    .join('');
            } catch (error) {
                testResults.innerHTML = `
                    <div class="regex-test-result-item no-match">
                        <span class="regex-test-icon">✕</span>
                        <span>Error: ${error.message}</span>
                    </div>
                `;
            }
        }

        // Event listeners for Reflow Regex Gen
        document.addEventListener('DOMContentLoaded', function() {
            const existingInput = document.getElementById('regexExistingInput');
            const testInput = document.getElementById('regexTestInput');

            if (existingInput) {
                existingInput.addEventListener('input', (e) => {
                    const parsed = parseImportedRegexPattern(e.target.value);
                    if (e.target.value.trim() === '') {
                        regexImportedPattern = '';
                        const status = document.getElementById('regexImportStatus');
                        if (status) status.style.display = 'none';
                        generateRegexPattern();
                    } else if (parsed) {
                        regexImportedPattern = parsed;
                        showRegexImportStatus('Valid regex imported successfully!');
                        generateRegexPattern();
                    } else {
                        regexImportedPattern = '';
                        showRegexImportStatus('Invalid regex pattern. Please check your syntax.', true);
                    }
                });
            }

            if (testInput) {
                testInput.addEventListener('input', testRegexPattern);
            }
        });

        // LocalStorage functionality
        function saveToLocalStorage() {
            try {
                const dataToSave = {
                    version: '1.0',
                    savedAt: new Date().toISOString(),
                    appData: appData,
                    compareData: compareData,
                    currentView: currentView,
                    comparisonActive: comparisonActive,
                    checkedItems: [...checkedItems],
                    excludedItems: [...excludedItems],
                    serverUrl: document.getElementById('serverUrl')?.value || '',
                    reflowTitle: document.getElementById('reflowTitle')?.value || '',
                    uiState: {
                        currentView: currentView,
                        comparisonActive: comparisonActive
                    }
                };

                localStorage.setItem('niagaraNavigatorData', JSON.stringify(dataToSave));
                console.log('Data saved to localStorage');
            } catch (error) {
                if (error.name === 'QuotaExceededError') {
                    console.warn('CSV data too large for localStorage (browser limit ~5-10MB). Auto-save disabled for this session.');
                    console.info('Your work is still safe - just reload your CSV file when you return.');
                    // Don't show error to user - localStorage is just a convenience feature
                } else {
                    console.error('Error saving to localStorage:', error);
                }
            }
        }

        function loadFromLocalStorage() {
            try {
                const savedData = localStorage.getItem('niagaraNavigatorData');
                if (!savedData) {
                    return false;
                }

                const data = JSON.parse(savedData);

                // Restore data
                if (data.appData) {
                    appData = data.appData;
                }
                if (data.compareData) {
                    compareData = data.compareData;
                }

                currentView = data.currentView || 'tree';
                comparisonActive = data.comparisonActive || false;

                // Restore checked and excluded items
                if (data.checkedItems) {
                    checkedItems = new Set(data.checkedItems);
                }
                if (data.excludedItems) {
                    excludedItems = new Set(data.excludedItems);
                }

                // Restore form values
                if (data.serverUrl) {
                    const serverUrlInput = document.getElementById('serverUrl');
                    if (serverUrlInput) {
                        serverUrlInput.value = data.serverUrl;
                    }
                }
                if (data.reflowTitle) {
                    const reflowTitleInput = document.getElementById('reflowTitle');
                    if (reflowTitleInput) {
                        reflowTitleInput.value = data.reflowTitle;
                    }
                }

                console.log('Data loaded from localStorage');

                // Show restoration notice
                const savedAt = new Date(data.savedAt).toLocaleString();
                showToast(`Previous session restored (saved ${savedAt})`, 'info', 5000);

                return true;
            } catch (error) {
                console.error('Error loading from localStorage:', error);
                return false;
            }
        }

        function clearAllData() {
            if (!confirm('Are you sure you want to clear all data? This will remove all imported files, templates, and settings. This action cannot be undone.')) {
                return;
            }

            try {
                // Clear localStorage
                localStorage.removeItem('niagaraNavigatorData');
                localStorage.removeItem('niagaraNavigatorCheckedItems');
                localStorage.removeItem('niagaraNavigatorExcludedItems');

                // Reset application state
                appData = null;
                compareData = null;
                currentView = 'tree';
                comparisonActive = false;

                // Clear checkbox state
                checkedItems.clear();
                updateCheckboxDisplay();
                updateCheckedCounter();

                // Clear excluded items state
                excludedItems.clear();

                // Clear form inputs
                const serverUrlInput = document.getElementById('serverUrl');
                const reflowTitleInput = document.getElementById('reflowTitle');
                if (serverUrlInput) {
                    serverUrlInput.value = '{server}';
                }
                if (reflowTitleInput) {
                    reflowTitleInput.value = '';
                }

                // Clear file inputs
                const fileInput = document.getElementById('fileInput');
                const compareFileInput = document.getElementById('compareFileInput');
                if (fileInput) fileInput.value = '';
                if (compareFileInput) compareFileInput.value = '';

                // Clear all view content
                const treeView = document.getElementById('treeView');
                const templatesView = document.getElementById('templatesView');
                const detailPanel = document.getElementById('detailPanel');
                if (treeView) treeView.innerHTML = '';
                if (templatesView) templatesView.innerHTML = '';
                if (detailPanel) detailPanel.classList.remove('show');

                // Reset detected drivers display
                const detectedDriversEl = document.querySelector('.detected-drivers .value');
                if (detectedDriversEl) {
                    detectedDriversEl.textContent = 'None detected';
                }

                // Update UI
                updateDisplay();

                // Hide comparison elements
                document.getElementById('compareBogBtn').style.display = 'none';
                document.getElementById('clearComparisonBtn').style.display = 'none';
                document.getElementById('comparisonBtn').style.display = 'none';
                document.getElementById('compareFileInfo').style.display = 'none';

                // Clear file names and reset to initial state
                document.getElementById('fileName').textContent = 'None';
                document.getElementById('compareFileName').textContent = '';

                showToast('All data cleared successfully', 'success');
                console.log('All data cleared');
            } catch (error) {
                console.error('Error clearing data:', error);
                showToast('Error clearing data', 'error');
            }
        }

        // Initialize application
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Niagara Navigator - CSV Point Explorer initialized');

            // Try to load saved data
            const dataLoaded = loadFromLocalStorage();

            if (dataLoaded && appData) {
                // Update UI to reflect loaded data
                updateDisplay();

                // Load checkbox state
                loadCheckboxesFromLocalStorage();

                // Show file info if data exists
                if (appData) {
                    document.getElementById('fileName').textContent = 'Restored from localStorage';
                    document.getElementById('compareBogBtn').style.display = 'inline-flex';
                }

                if (compareData) {
                    document.getElementById('compareFileName').textContent = 'Restored from localStorage';
                    document.getElementById('compareFileInfo').style.display = 'block';
                    document.getElementById('clearComparisonBtn').style.display = 'inline-flex';
                    document.getElementById('comparisonBtn').style.display = 'inline-flex';
                }
            }
        });

        // === TYPO CHECKING FUNCTIONALITY ===

        // Calculate Levenshtein distance between two strings
        function levenshteinDistance(str1, str2) {
            const len1 = str1.length;
            const len2 = str2.length;
            const matrix = Array(len1 + 1).fill(null).map(() => Array(len2 + 1).fill(0));

            for (let i = 0; i <= len1; i++) matrix[i][0] = i;
            for (let j = 0; j <= len2; j++) matrix[0][j] = j;

            for (let i = 1; i <= len1; i++) {
                for (let j = 1; j <= len2; j++) {
                    const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;
                    matrix[i][j] = Math.min(
                        matrix[i - 1][j] + 1,     // deletion
                        matrix[i][j - 1] + 1,     // insertion
                        matrix[i - 1][j - 1] + cost // substitution
                    );
                }
            }
            return matrix[len1][len2];
        }

        // Strip all numbers from string
        function stripNumbers(str) {
            return str.replace(/\d+/g, '');
        }

        // Calculate similarity ratio (0-1) between two strings with numbers removed
        function similarityRatio(str1, str2) {
            // Strip all numbers before comparison
            const stripped1 = stripNumbers(str1.toLowerCase());
            const stripped2 = stripNumbers(str2.toLowerCase());

            // If stripped versions are identical, they only differ in numbers - return 0 similarity
            if (stripped1 === stripped2) {
                return 0;
            }

            // Calculate similarity on letter-only versions
            const distance = levenshteinDistance(stripped1, stripped2);
            const maxLength = Math.max(stripped1.length, stripped2.length);
            return 1 - (distance / maxLength);
        }

        // Extract all point names from devices
        function extractPointNames(devices) {
            const pointNames = new Map(); // Map<pointName, Array<{device, path}>>

            devices.forEach(device => {
                device.points.forEach(point => {
                    const name = point.name;
                    if (!pointNames.has(name)) {
                        pointNames.set(name, []);
                    }
                    pointNames.get(name).push({
                        device: device.path,
                        fullPath: point.path
                    });
                });
            });

            return pointNames;
        }

        // Find potential typos by grouping similar names
        function findTypos(devices, similarityThreshold = 0.85, minFrequencyRatio = 0.2) {
            const pointNames = extractPointNames(devices);
            const nameArray = Array.from(pointNames.keys());
            const groups = [];
            const processed = new Set();

            // Group similar point names
            nameArray.forEach((name1, idx1) => {
                if (processed.has(name1)) return;

                const group = {
                    pattern: name1,
                    variants: []
                };

                nameArray.forEach((name2, idx2) => {
                    if (idx1 === idx2 || processed.has(name2)) return;

                    // Calculate similarity (returns 0 if only numbers differ)
                    const similarity = similarityRatio(name1, name2);

                    // Group if similarity is high enough (0 means only numbers differ, so skip)
                    if (similarity >= similarityThreshold && similarity > 0) {
                        const count2 = pointNames.get(name2).length;
                        group.variants.push({
                            name: name2,
                            count: count2,
                            locations: pointNames.get(name2)
                        });
                        processed.add(name2);
                    }
                });

                // Add the base name to the group
                const count1 = pointNames.get(name1).length;
                group.variants.push({
                    name: name1,
                    count: count1,
                    locations: pointNames.get(name1)
                });
                processed.add(name1);

                // Only keep groups with multiple variants
                if (group.variants.length > 1) {
                    // Sort variants by count (most common first)
                    group.variants.sort((a, b) => b.count - a.count);

                    // Update pattern to the most common variant
                    group.pattern = group.variants[0].name;

                    groups.push(group);
                }
            });

            // Identify potential typos (low-frequency variants)
            const typos = [];
            groups.forEach(group => {
                const maxCount = group.variants[0].count;
                const totalCount = group.variants.reduce((sum, v) => sum + v.count, 0);

                group.variants.forEach((variant, index) => {
                    // Skip the most common variant
                    if (index === 0) return;

                    const frequencyRatio = variant.count / totalCount;

                    // Flag as potential typo if it's significantly less common
                    if (frequencyRatio < minFrequencyRatio) {
                        const confidence = Math.round((1 - frequencyRatio) * 100);

                        typos.push({
                            potentialTypo: variant.name,
                            suggestedCorrection: group.pattern,
                            typoCount: variant.count,
                            correctCount: maxCount,
                            confidence: confidence,
                            locations: variant.locations,
                            allVariants: group.variants.map(v => `${v.name} (${v.count})`)
                        });
                    }
                });
            });

            // Sort by confidence (highest first)
            typos.sort((a, b) => b.confidence - a.confidence);

            return typos;
        }

        // Run typo check and display results
        function runTypoCheck() {
            if (!appData || !appData.devices) {
                showToast('Please load a CSV file first');
                return;
            }

            const devices = Array.from(appData.devices.values()).filter(d => !excludedItems.has(d.path));
            const typos = findTypos(devices);

            const resultsDiv = document.getElementById('typoCheckResults');

            if (typos.length === 0) {
                resultsDiv.innerHTML = `
                    <div class="summary-card" style="text-align: center; padding: 40px;">
                        <h3 style="color: var(--success-color);">✓ No Potential Typos Found</h3>
                        <p style="margin-top: 10px; opacity: 0.8;">All point names appear consistent!</p>
                    </div>
                `;
                document.getElementById('exportTypoBtn').style.display = 'none';
                return;
            }

            // Generate report HTML
            let html = `
                <div class="summary-card">
                    <h3 style="margin-bottom: 15px;">Found ${typos.length} Potential Typo${typos.length !== 1 ? 's' : ''}</h3>
                    <div style="margin-top: 10px; padding: 12px; background: rgba(255, 152, 0, 0.1); border-left: 3px solid var(--warning-color); border-radius: 4px;">
                        <strong>Note:</strong> These are potential typos based on similarity analysis. Please review each suggestion carefully.
                    </div>
                </div>

                <div style="margin-top: 20px;">
                    <table style="width: 100%; border-collapse: collapse; background: var(--surface-color); border-radius: 8px; overflow: hidden;">
                        <thead>
                            <tr style="background: var(--secondary-color);">
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Confidence</th>
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Potential Typo</th>
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Suggested Correction</th>
                                <th style="padding: 12px; text-align: center; font-weight: 600;">Occurrences</th>
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Locations</th>
                            </tr>
                        </thead>
                        <tbody>
            `;

            typos.forEach((typo, index) => {
                const confidenceColor = typo.confidence > 80 ? 'var(--error-color)' :
                                       typo.confidence > 60 ? 'var(--warning-color)' :
                                       'var(--text-secondary)';

                const locationsSummary = typo.locations.length > 3
                    ? typo.locations.slice(0, 3).map(l => l.device).join(', ') + ` (+${typo.locations.length - 3} more)`
                    : typo.locations.map(l => l.device).join(', ');

                html += `
                    <tr style="border-bottom: 1px solid var(--border-color); ${index % 2 === 0 ? 'background: rgba(255,255,255,0.02);' : ''}">
                        <td style="padding: 12px;">
                            <span style="display: inline-block; padding: 4px 12px; background: ${confidenceColor}20; color: ${confidenceColor}; border-radius: 12px; font-weight: 600; font-size: 12px;">
                                ${typo.confidence}%
                            </span>
                        </td>
                        <td style="padding: 12px; font-family: monospace; color: var(--error-color);">${typo.potentialTypo}</td>
                        <td style="padding: 12px; font-family: monospace; color: var(--success-color);">${typo.suggestedCorrection}</td>
                        <td style="padding: 12px; text-align: center;">
                            <span style="color: var(--error-color);">${typo.typoCount}</span> vs
                            <span style="color: var(--success-color);">${typo.correctCount}</span>
                        </td>
                        <td style="padding: 12px; font-size: 11px; color: var(--text-secondary);">
                            <details>
                                <summary style="cursor: pointer; color: var(--accent-color);">${typo.locations.length} location${typo.locations.length !== 1 ? 's' : ''}</summary>
                                <div style="margin-top: 8px; padding: 8px; background: var(--background-color); border-radius: 4px;">
                                    ${typo.locations.map(l => `<div style="margin: 2px 0;">${l.fullPath}</div>`).join('')}
                                </div>
                            </details>
                        </td>
                    </tr>
                `;
            });

            html += `
                        </tbody>
                    </table>
                </div>
            `;

            resultsDiv.innerHTML = html;
            document.getElementById('exportTypoBtn').style.display = 'inline-flex';

            // Store typos for export
            window.currentTypoReport = typos;

            showToast(`Found ${typos.length} potential typo${typos.length !== 1 ? 's' : ''}`);
        }

        // Export typo report to CSV
        function exportTypoReport() {
            if (!window.currentTypoReport || window.currentTypoReport.length === 0) {
                showToast('No typo report to export');
                return;
            }

            const typos = window.currentTypoReport;
            let csv = 'Confidence,Potential Typo,Suggested Correction,Typo Occurrences,Correct Occurrences,Locations\n';

            typos.forEach(typo => {
                const locations = typo.locations.map(l => l.fullPath).join('; ');
                csv += `${typo.confidence}%,"${typo.potentialTypo}","${typo.suggestedCorrection}",${typo.typoCount},${typo.correctCount},"${locations}"\n`;
            });

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'niagara-typo-report.csv';
            a.click();
            URL.revokeObjectURL(url);

            showToast('Typo report exported');
        }

        // === FACET CHECKING FUNCTIONALITY ===

        // Parse facets string into object
        function parseFacets(facetsString) {
            const facets = {};
            if (!facetsString) return facets;

            // Split by pipe to get individual facets
            const pairs = facetsString.split('|');

            pairs.forEach(pair => {
                const match = pair.match(/([^=]+)=([^:]+):(.*)/);
                if (match) {
                    const key = match[1].trim();
                    const type = match[2].trim();
                    const value = match[3].trim();
                    facets[key] = { type, value };
                }
            });

            return facets;
        }

        // Check if facets have issues
        function checkFacetIssues(facets) {
            const issues = [];

            // Check for null units
            if (facets.units) {
                const unitsValue = facets.units.value;
                if (unitsValue.includes('null') || unitsValue === 'null;;;;') {
                    issues.push({
                        type: 'Null Units',
                        facet: 'units',
                        value: unitsValue
                    });
                }
            }

            // Check for default boolean text
            if (facets.trueText && facets.falseText) {
                const trueTextValue = facets.trueText.value;
                const falseTextValue = facets.falseText.value;

                if (trueTextValue === 'true' && falseTextValue === 'false') {
                    issues.push({
                        type: 'Default Boolean Text',
                        facet: 'trueText/falseText',
                        value: `trueText=${trueTextValue}, falseText=${falseTextValue}`
                    });
                }
            }

            return issues;
        }

        // Run facet check and display results
        function runFacetCheck() {
            if (!appData || !appData.facetsMap) {
                showToast('Please load a CSV file with Facets column first');
                return;
            }

            if (appData.facetsMap.size === 0) {
                showToast('No facets data found in CSV');
                return;
            }

            const issuesFound = [];

            // Check each point's facets
            appData.facetsMap.forEach((facetsString, pointPath) => {
                const facets = parseFacets(facetsString);
                const issues = checkFacetIssues(facets);

                if (issues.length > 0) {
                    issues.forEach(issue => {
                        issuesFound.push({
                            pointPath: pointPath,
                            issueType: issue.type,
                            facet: issue.facet,
                            value: issue.value,
                            fullFacetsString: facetsString
                        });
                    });
                }
            });

            const resultsDiv = document.getElementById('facetCheckResults');

            if (issuesFound.length === 0) {
                resultsDiv.innerHTML = `
                    <div class="summary-card" style="text-align: center; padding: 40px;">
                        <h3 style="color: var(--success-color);">✓ No Facet Issues Found</h3>
                        <p style="margin-top: 10px; opacity: 0.8;">All facets are properly configured!</p>
                    </div>
                `;
                document.getElementById('exportFacetBtn').style.display = 'none';
                return;
            }

            // Generate report HTML
            let html = `
                <div class="summary-card">
                    <h3 style="margin-bottom: 15px;">Found ${issuesFound.length} Facet Issue${issuesFound.length !== 1 ? 's' : ''}</h3>
                    <div style="margin-top: 10px; padding: 12px; background: rgba(255, 152, 0, 0.1); border-left: 3px solid var(--warning-color); border-radius: 4px;">
                        <strong>Issues Found:</strong>
                        <ul style="margin: 8px 0 0 20px;">
                            <li>Null Units: ${issuesFound.filter(i => i.issueType === 'Null Units').length}</li>
                            <li>Default Boolean Text: ${issuesFound.filter(i => i.issueType === 'Default Boolean Text').length}</li>
                        </ul>
                    </div>
                </div>

                <div style="margin-top: 20px;">
                    <table style="width: 100%; border-collapse: collapse; background: var(--surface-color); border-radius: 8px; overflow: hidden;">
                        <thead>
                            <tr style="background: var(--secondary-color);">
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Issue Type</th>
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Point Path</th>
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Facet</th>
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Value</th>
                            </tr>
                        </thead>
                        <tbody>
            `;

            issuesFound.forEach((issue, index) => {
                const typeColor = issue.issueType === 'Null Units' ? 'var(--error-color)' : 'var(--warning-color)';

                html += `
                    <tr style="border-bottom: 1px solid var(--border-color); ${index % 2 === 0 ? 'background: rgba(255,255,255,0.02);' : ''}">
                        <td style="padding: 12px;">
                            <span style="display: inline-block; padding: 4px 12px; background: ${typeColor}20; color: ${typeColor}; border-radius: 12px; font-weight: 600; font-size: 12px;">
                                ${issue.issueType}
                            </span>
                        </td>
                        <td style="padding: 12px; font-family: monospace; font-size: 11px;">${issue.pointPath}</td>
                        <td style="padding: 12px; color: var(--text-secondary);">${issue.facet}</td>
                        <td style="padding: 12px; font-family: monospace; font-size: 11px; color: var(--text-muted);">${issue.value}</td>
                    </tr>
                `;
            });

            html += `
                        </tbody>
                    </table>
                </div>
            `;

            resultsDiv.innerHTML = html;
            document.getElementById('exportFacetBtn').style.display = 'inline-flex';

            // Store issues for export
            window.currentFacetReport = issuesFound;

            showToast(`Found ${issuesFound.length} facet issue${issuesFound.length !== 1 ? 's' : ''}`);
        }

        // Export facet report to CSV
        function exportFacetReport() {
            if (!window.currentFacetReport || window.currentFacetReport.length === 0) {
                showToast('No facet report to export');
                return;
            }

            const issues = window.currentFacetReport;
            let csv = 'Issue Type,Point Path,Facet,Value,Full Facets String\n';

            issues.forEach(issue => {
                csv += `"${issue.issueType}","${issue.pointPath}","${issue.facet}","${issue.value}","${issue.fullFacetsString}"\n`;
            });

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'niagara-facet-report.csv';
            a.click();
            URL.revokeObjectURL(url);

            showToast('Facet report exported');
        }

        // === HISTORY EXTENSION CHECK FUNCTIONALITY ===

        let historyData = null;

        function loadHistoryCSV(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const text = e.target.result;
                const lines = text.split('\n').filter(line => line.trim());

                // Parse CSV
                const headers = lines[0].split(',').map(h => h.trim());
                historyData = [];

                for (let i = 1; i < lines.length; i++) {
                    const values = lines[i].split(',').map(v => v.trim());
                    if (values.length >= 3) {
                        historyData.push({
                            slotPath: values[0].replace(/^slot:/, ''), // Remove slot: prefix
                            extension: values[1],
                            enabled: values[2].toLowerCase() === 'true'
                        });
                    }
                }

                showToast(`Loaded ${historyData.length} history extension records`);
                document.getElementById('runHistoryBtn').style.display = 'inline-flex';
            };
            reader.readAsText(file);
        }

        function runHistoryCheck() {
            if (!appData) {
                showToast('Please load a main CSV file first', 'error');
                return;
            }

            if (!historyData) {
                showToast('Please load a history CSV file first', 'error');
                return;
            }

            const results = {
                missedExtensions: [],
                disabledExtensions: []
            };

            // Check 1: Find disabled extensions
            historyData.forEach(record => {
                if (!record.enabled) {
                    results.disabledExtensions.push(record);
                }
            });

            // Check 2: Find potentially missed history extensions
            // Group points from main CSV by point name
            const pointsByName = new Map();

            // Get all points from appData
            let allPoints = [];
            if (appData.points && typeof appData.points.values === 'function') {
                allPoints = Array.from(appData.points.values());
            } else if (appData.points && Array.isArray(appData.points)) {
                allPoints = appData.points;
            }

            // Group by point name (last segment of path)
            allPoints.forEach(point => {
                if (point.path) {
                    const pathParts = point.path.split('/');
                    const pointName = pathParts[pathParts.length - 1];

                    if (!pointsByName.has(pointName)) {
                        pointsByName.set(pointName, []);
                    }
                    pointsByName.get(pointName).push(point.path);
                }
            });

            // For each point name group, check if most have history but some don't
            pointsByName.forEach((paths, pointName) => {
                if (paths.length < 3) return; // Skip groups with less than 3 points

                // Count how many have history extensions
                const pathsWithHistory = paths.filter(path =>
                    historyData.some(h => h.slotPath === path)
                );

                const percentWithHistory = (pathsWithHistory.length / paths.length) * 100;

                // If 80% or more have history, flag the ones that don't
                if (percentWithHistory >= 80) {
                    const pathsWithoutHistory = paths.filter(path =>
                        !historyData.some(h => h.slotPath === path)
                    );

                    pathsWithoutHistory.forEach(path => {
                        results.missedExtensions.push({
                            path: path,
                            pointName: pointName,
                            coverage: `${pathsWithHistory.length}/${paths.length} similar points have history`,
                            percent: percentWithHistory.toFixed(0)
                        });
                    });
                }
            });

            displayHistoryResults(results);
        }

        function displayHistoryResults(results) {
            const resultsDiv = document.getElementById('historyCheckResults');

            let html = `
                <div class="summary-card">
                    <h3>Results Summary</h3>
                    <div class="summary-stats">
                        <div class="stat">
                            <div class="stat-value">${results.disabledExtensions.length}</div>
                            <div class="stat-label">Disabled Extensions</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value">${results.missedExtensions.length}</div>
                            <div class="stat-label">Potentially Missed Extensions</div>
                        </div>
                    </div>
                </div>
            `;

            // Disabled extensions section
            if (results.disabledExtensions.length > 0) {
                html += `
                    <div class="summary-card" style="margin-top: 20px;">
                        <h3 style="color: var(--warning-color);">Disabled History Extensions (${results.disabledExtensions.length})</h3>
                        <p style="margin-top: 10px; opacity: 0.9;">These points have history extensions but they are not enabled.</p>
                        <table style="width: 100%; border-collapse: collapse; margin-top: 15px; background: var(--surface-color); border-radius: 8px; overflow: hidden;">
                            <thead>
                                <tr style="background: var(--secondary-color);">
                                    <th style="padding: 12px; text-align: left; font-weight: 600;">Point Path</th>
                                    <th style="padding: 12px; text-align: left; font-weight: 600;">Extension Type</th>
                                </tr>
                            </thead>
                            <tbody>
                `;

                results.disabledExtensions.forEach((record, index) => {
                    html += `
                        <tr style="border-bottom: 1px solid var(--border-color); ${index % 2 === 0 ? 'background: rgba(255,255,255,0.02);' : ''}">
                            <td style="padding: 12px; font-family: monospace; font-size: 11px;">${record.slotPath}</td>
                            <td style="padding: 12px;">${record.extension}</td>
                        </tr>
                    `;
                });

                html += `
                            </tbody>
                        </table>
                    </div>
                `;
            }

            // Missed extensions section
            if (results.missedExtensions.length > 0) {
                html += `
                    <div class="summary-card" style="margin-top: 20px;">
                        <h3 style="color: var(--accent-color);">Potentially Missed Extensions (${results.missedExtensions.length})</h3>
                        <p style="margin-top: 10px; opacity: 0.9;">These points don't have history extensions, but most similar points do.</p>
                        <table style="width: 100%; border-collapse: collapse; margin-top: 15px; background: var(--surface-color); border-radius: 8px; overflow: hidden;">
                            <thead>
                                <tr style="background: var(--secondary-color);">
                                    <th style="padding: 12px; text-align: left; font-weight: 600;">Point Path</th>
                                    <th style="padding: 12px; text-align: left; font-weight: 600;">Point Name</th>
                                    <th style="padding: 12px; text-align: left; font-weight: 600;">Coverage</th>
                                </tr>
                            </thead>
                            <tbody>
                `;

                results.missedExtensions.forEach((record, index) => {
                    html += `
                        <tr style="border-bottom: 1px solid var(--border-color); ${index % 2 === 0 ? 'background: rgba(255,255,255,0.02);' : ''}">
                            <td style="padding: 12px; font-family: monospace; font-size: 11px;">${record.path}</td>
                            <td style="padding: 12px; font-weight: 600;">${record.pointName}</td>
                            <td style="padding: 12px;">
                                <span style="display: inline-block; padding: 4px 12px; background: var(--accent-color)20; color: var(--accent-color); border-radius: 12px; font-weight: 600; font-size: 12px;">
                                    ${record.coverage} (${record.percent}%)
                                </span>
                            </td>
                        </tr>
                    `;
                });

                html += `
                            </tbody>
                        </table>
                    </div>
                `;
            }

            if (results.disabledExtensions.length === 0 && results.missedExtensions.length === 0) {
                html += `
                    <div class="summary-card" style="text-align: center; padding: 40px; margin-top: 20px;">
                        <h3 style="color: var(--success-color);">✓ No Issues Found</h3>
                        <p style="margin-top: 10px; opacity: 0.8;">All history extensions are properly configured!</p>
                    </div>
                `;
            }

            resultsDiv.innerHTML = html;

            if (results.disabledExtensions.length > 0 || results.missedExtensions.length > 0) {
                showToast(`Found ${results.disabledExtensions.length} disabled and ${results.missedExtensions.length} potentially missed extensions`);
            } else {
                showToast('No issues found!', 'success');
            }
        }

        // === ALARM EXTENSION CHECK FUNCTIONALITY ===

        let alarmData = null;

        async function loadAlarmCSV(event) {
            const file = event.target.files[0];
            if (!file) return;

            try {
                const text = await file.text();
                const lines = text.split(/\r?\n/).filter(line => line.trim());

                if (lines.length < 2) {
                    showToast('CSV must have at least header and one row', 'error');
                    return;
                }

                // Parse CSV (columns: Point, Alarm Extension, Enabled)
                alarmData = [];
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;

                    const parts = line.split(',');
                    if (parts.length >= 3) {
                        let point = parts[0].trim().replace(/^slot:/, '');
                        const extension = parts[1].trim();
                        const enabled = parts[2].trim().toLowerCase() === 'true';

                        alarmData.push({
                            point: point,
                            extension: extension,
                            enabled: enabled
                        });
                    }
                }

                showToast(`Loaded ${alarmData.length} alarm extension records`, 'success');
                document.getElementById('runAlarmBtn').style.display = 'inline-flex';

            } catch (error) {
                showToast('Error parsing alarm CSV: ' + error.message, 'error');
                console.error(error);
            }
        }

        function runAlarmCheck() {
            if (!alarmData || alarmData.length === 0) {
                showToast('Please load alarm CSV first', 'error');
                return;
            }

            const results = {
                disabledExtensions: [],
                missedExtensions: []
            };

            // Check 1: Find disabled extensions
            alarmData.forEach(record => {
                if (!record.enabled) {
                    results.disabledExtensions.push({
                        path: record.point,
                        extension: record.extension
                    });
                }
            });

            // Check 2: Find potentially missed extensions
            // Group points by their base name pattern
            const pointGroups = new Map();

            alarmData.forEach(record => {
                // Extract point name from path
                const pathParts = record.point.split('/');
                const pointName = pathParts[pathParts.length - 1];

                if (!pointGroups.has(pointName)) {
                    pointGroups.set(pointName, []);
                }
                pointGroups.get(pointName).push(record);
            });

            // For each point name, check if 80%+ have alarm but some don't
            pointGroups.forEach((records, pointName) => {
                if (records.length < 3) return; // Need at least 3 to make pattern meaningful

                const withAlarm = records.filter(r => r.extension).length;
                const withoutAlarm = records.length - withAlarm;
                const coverage = withAlarm / records.length;

                // If 80%+ have alarm extension, flag the ones without
                if (coverage >= 0.8 && withoutAlarm > 0) {
                    records.forEach(record => {
                        if (!record.extension || record.extension === '') {
                            results.missedExtensions.push({
                                path: record.point,
                                pointName: pointName,
                                coverage: `${withAlarm}/${records.length}`,
                                percent: Math.round(coverage * 100)
                            });
                        }
                    });
                }
            });

            displayAlarmResults(results);
        }

        function displayAlarmResults(results) {
            const resultsDiv = document.getElementById('alarmCheckResults');
            let html = '';

            // Disabled Extensions Section
            if (results.disabledExtensions.length > 0) {
                html += `
                    <div class="summary-card">
                        <h3 style="color: var(--warning-color); margin-bottom: 15px;">⚠ Disabled Alarm Extensions (${results.disabledExtensions.length})</h3>
                        <p style="opacity: 0.8; margin-bottom: 20px;">These alarm extensions exist but are currently disabled.</p>
                        <table style="width: 100%; border-collapse: collapse;">
                            <thead>
                                <tr style="border-bottom: 2px solid var(--border-color); background: rgba(255,255,255,0.05);">
                                    <th style="padding: 12px; text-align: left; font-weight: 600;">Point Path</th>
                                    <th style="padding: 12px; text-align: left; font-weight: 600;">Alarm Extension</th>
                                </tr>
                            </thead>
                            <tbody>
                `;

                results.disabledExtensions.forEach((record, index) => {
                    html += `
                        <tr style="border-bottom: 1px solid var(--border-color); ${index % 2 === 0 ? 'background: rgba(255,255,255,0.02);' : ''}">
                            <td style="padding: 12px; font-family: monospace; font-size: 11px;">${record.path}</td>
                            <td style="padding: 12px;">${record.extension}</td>
                        </tr>
                    `;
                });

                html += `
                            </tbody>
                        </table>
                    </div>
                `;
            }

            // Potentially Missed Extensions Section
            if (results.missedExtensions.length > 0) {
                html += `
                    <div class="summary-card" style="margin-top: 20px;">
                        <h3 style="color: var(--accent-color); margin-bottom: 15px;">🔍 Potentially Missed Alarm Extensions (${results.missedExtensions.length})</h3>
                        <p style="opacity: 0.8; margin-bottom: 20px;">These points might need alarm extensions based on similar points having them.</p>
                        <table style="width: 100%; border-collapse: collapse;">
                            <thead>
                                <tr style="border-bottom: 2px solid var(--border-color); background: rgba(255,255,255,0.05);">
                                    <th style="padding: 12px; text-align: left; font-weight: 600;">Point Path</th>
                                    <th style="padding: 12px; text-align: left; font-weight: 600;">Point Name</th>
                                    <th style="padding: 12px; text-align: left; font-weight: 600;">Coverage</th>
                                </tr>
                            </thead>
                            <tbody>
                `;

                results.missedExtensions.forEach((record, index) => {
                    html += `
                        <tr style="border-bottom: 1px solid var(--border-color); ${index % 2 === 0 ? 'background: rgba(255,255,255,0.02);' : ''}">
                            <td style="padding: 12px; font-family: monospace; font-size: 11px;">${record.path}</td>
                            <td style="padding: 12px; font-weight: 600;">${record.pointName}</td>
                            <td style="padding: 12px;">
                                <span style="display: inline-block; padding: 4px 12px; background: var(--accent-color)20; color: var(--accent-color); border-radius: 12px; font-weight: 600; font-size: 12px;">
                                    ${record.coverage} (${record.percent}%)
                                </span>
                            </td>
                        </tr>
                    `;
                });

                html += `
                            </tbody>
                        </table>
                    </div>
                `;
            }

            if (results.disabledExtensions.length === 0 && results.missedExtensions.length === 0) {
                html += `
                    <div class="summary-card" style="text-align: center; padding: 40px; margin-top: 20px;">
                        <h3 style="color: var(--success-color);">✓ No Issues Found</h3>
                        <p style="margin-top: 10px; opacity: 0.8;">All alarm extensions are properly configured!</p>
                    </div>
                `;
            }

            resultsDiv.innerHTML = html;

            if (results.disabledExtensions.length > 0 || results.missedExtensions.length > 0) {
                showToast(`Found ${results.disabledExtensions.length} disabled and ${results.missedExtensions.length} potentially missed extensions`);
            } else {
                showToast('No issues found!', 'success');
            }
        }

        // === CHECKOUT REPORT FUNCTIONALITY ===

        let checkoutLogo = null;
        let checkoutHistoryData = null;
        let checkoutAlarmData = null;
        let checkoutEquipment = [];

        function checkExistingCheckoutData() {
            // Check if history data already loaded from History Extension Check tab
            if (historyData && historyData.length > 0 && !checkoutHistoryData) {
                // Map property names: slotPath → path
                checkoutHistoryData = historyData.map(record => ({
                    path: record.slotPath,
                    extension: record.extension,
                    enabled: record.enabled
                }));
                document.getElementById('checkoutHistoryStatus').textContent = `✓ ${checkoutHistoryData.length} records (from History Check)`;
                document.getElementById('checkoutHistoryStatus').style.color = 'var(--success-color)';
            }

            // Check if alarm data already loaded from Alarm Extension Check tab
            if (alarmData && alarmData.length > 0 && !checkoutAlarmData) {
                // Map property names: point → path
                checkoutAlarmData = alarmData.map(record => ({
                    path: record.point,
                    extension: record.extension,
                    enabled: record.enabled
                }));
                document.getElementById('checkoutAlarmStatus').textContent = `✓ ${checkoutAlarmData.length} records (from Alarm Check)`;
                document.getElementById('checkoutAlarmStatus').style.color = 'var(--success-color)';
            }
        }

        function handleCheckoutLogoUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                checkoutLogo = e.target.result;
                document.getElementById('logoPreviewImg').src = checkoutLogo;
                document.getElementById('logoPreview').style.display = 'block';
                showToast('Logo uploaded successfully', 'success');
            };
            reader.readAsDataURL(file);
        }

        function removeCheckoutLogo() {
            checkoutLogo = null;
            document.getElementById('logoPreview').style.display = 'none';
            document.getElementById('checkoutLogoInput').value = '';
            showToast('Logo removed', 'success');
        }

        async function loadCheckoutHistoryCSV(event) {
            const file = event.target.files[0];
            if (!file) return;

            try {
                const text = await file.text();
                const lines = text.split(/\r?\n/).filter(line => line.trim());

                if (lines.length < 2) {
                    showToast('CSV must have at least header and one row', 'error');
                    return;
                }

                checkoutHistoryData = [];
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;

                    const parts = line.split(',');
                    if (parts.length >= 3) {
                        checkoutHistoryData.push({
                            path: parts[0].trim().replace(/^slot:/, ''),
                            extension: parts[1].trim(),
                            enabled: parts[2].trim().toLowerCase() === 'true'
                        });
                    }
                }

                document.getElementById('checkoutHistoryStatus').textContent = `✓ ${checkoutHistoryData.length} records loaded`;
                document.getElementById('checkoutHistoryStatus').style.color = 'var(--success-color)';
                showToast('History CSV loaded', 'success');

            } catch (error) {
                showToast('Error loading history CSV: ' + error.message, 'error');
                console.error(error);
            }
        }

        async function loadCheckoutAlarmCSV(event) {
            const file = event.target.files[0];
            if (!file) return;

            try {
                const text = await file.text();
                const lines = text.split(/\r?\n/).filter(line => line.trim());

                if (lines.length < 2) {
                    showToast('CSV must have at least header and one row', 'error');
                    return;
                }

                checkoutAlarmData = [];
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;

                    const parts = line.split(',');
                    if (parts.length >= 3) {
                        checkoutAlarmData.push({
                            path: parts[0].trim().replace(/^slot:/, ''),
                            extension: parts[1].trim(),
                            enabled: parts[2].trim().toLowerCase() === 'true'
                        });
                    }
                }

                document.getElementById('checkoutAlarmStatus').textContent = `✓ ${checkoutAlarmData.length} records loaded`;
                document.getElementById('checkoutAlarmStatus').style.color = 'var(--success-color)';
                showToast('Alarm CSV loaded', 'success');

            } catch (error) {
                showToast('Error loading alarm CSV: ' + error.message, 'error');
                console.error(error);
            }
        }

        function buildCheckoutReport() {
            if (!appData || !appData.devices || !appData.points) {
                showToast('Please load a station CSV file first', 'error');
                return;
            }

            // Build equipment list from appData.devices
            checkoutEquipment = [];

            appData.devices.forEach(device => {
                const devicePoints = [];

                // Collect all points for this device
                appData.points.forEach((pointData, pointPath) => {
                    if (pointPath.startsWith(device.path + '/')) {
                        devicePoints.push({
                            path: pointPath,
                            name: pointPath.split('/').pop(),
                            type: pointData.type || 'N/A'
                        });
                    }
                });

                // Find template this device belongs to and count similar equipment
                let similarCount = 1; // Default to unique
                if (appData.templates && appData.templates.exact) {
                    const template = appData.templates.exact.find(t =>
                        t.devices.some(d => d.path === device.path)
                    );
                    if (template) {
                        similarCount = template.devices.length;
                    }
                }

                checkoutEquipment.push({
                    path: device.path,
                    name: device.name,
                    similarCount: similarCount,
                    points: devicePoints,
                    included: true
                });
            });

            // Display equipment review section
            displayEquipmentReview();

            showToast(`Found ${checkoutEquipment.length} equipment items`, 'success');
        }

        function displayEquipmentReview() {
            const section = document.getElementById('checkoutEquipmentSection');
            const listDiv = document.getElementById('checkoutEquipmentList');

            let html = '<div style="max-height: 400px; overflow-y: auto;">';

            checkoutEquipment.forEach((equip, index) => {
                html += `
                    <div style="padding: 12px; border-bottom: 1px solid var(--border-color); display: flex; align-items: center; gap: 12px; ${index % 2 === 0 ? 'background: rgba(255,255,255,0.02);' : ''}">
                        <input type="checkbox" id="equip_${index}" ${equip.included ? 'checked' : ''} onchange="toggleEquipment(${index})" style="cursor: pointer; width: 18px; height: 18px;">
                        <div style="flex: 1;">
                            <div style="font-weight: 600; margin-bottom: 4px;">${equip.name}</div>
                            <div style="font-family: monospace; font-size: 11px; color: var(--text-secondary);">${equip.path}</div>
                            <div style="margin-top: 4px; font-size: 12px;">
                                <span style="display: inline-block; padding: 2px 8px; background: var(--accent-color)20; color: var(--accent-color); border-radius: 12px; margin-right: 8px;">
                                    ${equip.similarCount} similar equipment
                                </span>
                                <span style="color: var(--text-secondary);">${equip.points.length} points</span>
                            </div>
                        </div>
                    </div>
                `;
            });

            html += '</div>';
            html += `
                <div style="margin-top: 15px; display: flex; gap: 10px;">
                    <button class="btn primary" onclick="generateCheckoutReport()" style="display: inline-flex;">
                        <i data-lucide="file-text" style="width: 16px; height: 16px;"></i>
                        Generate Report
                    </button>
                </div>
            `;

            listDiv.innerHTML = html;
            section.style.display = 'block';
            lucide.createIcons();
        }

        function toggleEquipment(index) {
            checkoutEquipment[index].included = document.getElementById(`equip_${index}`).checked;
        }

        function generateCheckoutReport() {
            const includedEquipment = checkoutEquipment.filter(e => e.included);

            if (includedEquipment.length === 0) {
                showToast('Please select at least one equipment item', 'error');
                return;
            }

            const previewDiv = document.getElementById('checkoutReportPreview');

            let html = `
                <div class="summary-card" id="reportContent" style="background: white; color: black; padding: 40px; max-width: 1200px; margin: 0 auto;">
                    <!-- Report Header -->
                    <div style="border-bottom: 3px solid #333; padding-bottom: 20px; margin-bottom: 30px; display: flex; justify-content: space-between; align-items: center;">
                        ${checkoutLogo ? `<img src="${checkoutLogo}" style="max-height: 60px;">` : '<div></div>'}
                        <div style="text-align: right;">
                            <h1 style="margin: 0; color: #333;">Commissioning Checkout Report</h1>
                            <p style="margin: 5px 0 0 0; color: #666;">Generated: ${new Date().toLocaleDateString()}</p>
                        </div>
                    </div>

                    <!-- Summary Section -->
                    <div style="margin-bottom: 30px; padding: 20px; background: #f5f5f5; border-radius: 8px;">
                        <h2 style="color: #333; margin-top: 0;">Summary</h2>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                            <div>
                                <div style="font-weight: 600; color: #666;">Total Equipment</div>
                                <div style="font-size: 24px; color: #333;">${includedEquipment.length}</div>
                            </div>
                            <div>
                                <div style="font-weight: 600; color: #666;">Total Points</div>
                                <div style="font-size: 24px; color: #333;">${includedEquipment.reduce((sum, e) => sum + e.points.length, 0)}</div>
                            </div>
                            ${checkoutHistoryData ? `
                            <div>
                                <div style="font-weight: 600; color: #666;">History Extensions</div>
                                <div style="font-size: 24px; color: #333;">${checkoutHistoryData.length}</div>
                            </div>
                            ` : ''}
                            ${checkoutAlarmData ? `
                            <div>
                                <div style="font-weight: 600; color: #666;">Alarm Extensions</div>
                                <div style="font-size: 24px; color: #333;">${checkoutAlarmData.length}</div>
                            </div>
                            ` : ''}
                        </div>
                    </div>

                    <!-- Equipment Section -->
                    <div style="margin-bottom: 40px; page-break-after: always;">
                        <h2 style="color: #333; border-bottom: 2px solid #333; padding-bottom: 10px;">Equipment & Points</h2>
            `;

            includedEquipment.forEach(equip => {
                html += `
                    <div style="margin-top: 25px; page-break-inside: avoid;">
                        <h3 style="color: #333; background: #f5f5f5; padding: 10px; border-radius: 4px; margin-bottom: 10px;">
                            ${equip.name}
                            <span style="font-size: 14px; font-weight: normal; color: #666; margin-left: 10px;">${equip.similarCount} similar equipment</span>
                        </h3>
                        <table style="width: 100%; border-collapse: collapse; margin-bottom: 20px;">
                            <thead>
                                <tr style="background: #e0e0e0;">
                                    <th style="padding: 8px; text-align: left; border: 1px solid #ccc; font-weight: 600;">Point Name</th>
                                    <th style="padding: 8px; text-align: left; border: 1px solid #ccc; font-weight: 600;">Type</th>
                                    <th style="padding: 8px; text-align: left; border: 1px solid #ccc; font-weight: 600;">Path</th>
                                </tr>
                            </thead>
                            <tbody>
                `;

                equip.points.forEach((point, i) => {
                    const pointName = point.path.split('/').pop();
                    html += `
                        <tr style="${i % 2 === 0 ? 'background: #fafafa;' : ''}">
                            <td style="padding: 8px; border: 1px solid #ccc;">${pointName}</td>
                            <td style="padding: 8px; border: 1px solid #ccc;">${point.type || 'N/A'}</td>
                            <td style="padding: 8px; border: 1px solid #ccc; font-family: monospace; font-size: 11px;">${point.path}</td>
                        </tr>
                    `;
                });

                html += `
                            </tbody>
                        </table>
                    </div>
                `;
            });

            html += `</div>`;

            // History Extensions Section
            if (checkoutHistoryData && checkoutHistoryData.length > 0) {
                html += `
                    <div style="margin-bottom: 40px; page-break-after: always;">
                        <h2 style="color: #333; border-bottom: 2px solid #333; padding-bottom: 10px;">History Extensions</h2>
                        <table style="width: 100%; border-collapse: collapse; margin-top: 15px;">
                            <thead>
                                <tr style="background: #e0e0e0;">
                                    <th style="padding: 8px; text-align: left; border: 1px solid #ccc; font-weight: 600;">Point Path</th>
                                    <th style="padding: 8px; text-align: left; border: 1px solid #ccc; font-weight: 600;">Extension</th>
                                    <th style="padding: 8px; text-align: center; border: 1px solid #ccc; font-weight: 600;">Enabled</th>
                                </tr>
                            </thead>
                            <tbody>
                `;

                checkoutHistoryData.forEach((record, i) => {
                    html += `
                        <tr style="${i % 2 === 0 ? 'background: #fafafa;' : ''}">
                            <td style="padding: 8px; border: 1px solid #ccc; font-family: monospace; font-size: 11px;">${record.path}</td>
                            <td style="padding: 8px; border: 1px solid #ccc;">${record.extension}</td>
                            <td style="padding: 8px; border: 1px solid #ccc; text-align: center;">
                                <span style="display: inline-block; padding: 4px 12px; background: ${record.enabled ? '#4CAF50' : '#f44336'}; color: white; border-radius: 12px; font-size: 12px; font-weight: 600;">
                                    ${record.enabled ? 'Yes' : 'No'}
                                </span>
                            </td>
                        </tr>
                    `;
                });

                html += `
                            </tbody>
                        </table>
                    </div>
                `;
            }

            // Alarm Extensions Section
            if (checkoutAlarmData && checkoutAlarmData.length > 0) {
                html += `
                    <div style="margin-bottom: 40px;">
                        <h2 style="color: #333; border-bottom: 2px solid #333; padding-bottom: 10px;">Alarm Extensions</h2>
                        <table style="width: 100%; border-collapse: collapse; margin-top: 15px;">
                            <thead>
                                <tr style="background: #e0e0e0;">
                                    <th style="padding: 8px; text-align: left; border: 1px solid #ccc; font-weight: 600;">Point Path</th>
                                    <th style="padding: 8px; text-align: left; border: 1px solid #ccc; font-weight: 600;">Extension</th>
                                    <th style="padding: 8px; text-align: center; border: 1px solid #ccc; font-weight: 600;">Enabled</th>
                                </tr>
                            </thead>
                            <tbody>
                `;

                checkoutAlarmData.forEach((record, i) => {
                    html += `
                        <tr style="${i % 2 === 0 ? 'background: #fafafa;' : ''}">
                            <td style="padding: 8px; border: 1px solid #ccc; font-family: monospace; font-size: 11px;">${record.path}</td>
                            <td style="padding: 8px; border: 1px solid #ccc;">${record.extension}</td>
                            <td style="padding: 8px; border: 1px solid #ccc; text-align: center;">
                                <span style="display: inline-block; padding: 4px 12px; background: ${record.enabled ? '#4CAF50' : '#f44336'}; color: white; border-radius: 12px; font-size: 12px; font-weight: 600;">
                                    ${record.enabled ? 'Yes' : 'No'}
                                </span>
                            </td>
                        </tr>
                    `;
                });

                html += `
                            </tbody>
                        </table>
                    </div>
                `;
            }

            html += `</div>`;

            previewDiv.innerHTML = html;
            previewDiv.style.display = 'block';
            document.getElementById('exportCheckoutBtn').style.display = 'inline-flex';

            showToast('Report generated successfully', 'success');

            // Scroll to report
            previewDiv.scrollIntoView({ behavior: 'smooth' });
        }

        function exportCheckoutReport() {
            const reportContent = document.getElementById('reportContent');
            if (!reportContent) {
                showToast('Please generate the report first', 'error');
                return;
            }

            // Create a printable window
            const printWindow = window.open('', '_blank');
            printWindow.document.write(`
                <!DOCTYPE html>
                <html>
                <head>
                    <title>Commissioning Checkout Report</title>
                    <style>
                        @media print {
                            @page { margin: 0.5in; }
                            body { margin: 0; }
                        }
                        body {
                            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
                            line-height: 1.6;
                        }
                        .page-break { page-break-after: always; }
                    </style>
                </head>
                <body>
                    ${reportContent.innerHTML}
                </body>
                </html>
            `);
            printWindow.document.close();
            printWindow.focus();

            setTimeout(() => {
                printWindow.print();
            }, 250);

            showToast('Opening print dialog...', 'success');
        }

        // === GRAPHICS REVIEW FUNCTIONALITY ===

        async function handleGraphicsMappingSelection(event) {
            if (!appData) {
                showToast('Please load a CSV file first', 'error');
                return;
            }

            const file = event.target.files[0];
            if (!file) return;

            try {
                const text = await file.text();
                const lines = text.split(/\r?\n/).filter(line => line.trim());

                if (lines.length < 2) {
                    showToast('Mapping CSV must have at least header and one row', 'error');
                    return;
                }

                // Parse CSV
                const mapping = new Map();
                let validCount = 0;
                let invalidCount = 0;

                // Skip header (line 0)
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;

                    // Split by comma, handling quoted values
                    const match = line.match(/^([^,]+),(.+)$/);
                    if (!match) continue;

                    let equipPath = match[1].trim();
                    const viewName = match[2].trim();

                    if (!equipPath || !viewName) continue;

                    // Clean slot: prefix
                    equipPath = equipPath.replace(/^slot:/, '');

                    // Decode $20 spaces and other encoded characters
                    equipPath = decodePxPath(equipPath);

                    // Check if equipment exists in loaded CSV
                    const equipmentExists = appData.devices.some(d => d.path === equipPath);

                    if (equipmentExists) {
                        mapping.set(viewName, equipPath);
                        validCount++;
                    } else {
                        console.warn(`Equipment not found in CSV: ${equipPath} (for view: ${viewName})`);
                        invalidCount++;
                    }
                }

                graphicsMappingData = mapping;

                // Display info
                const infoDiv = document.getElementById('graphicsMappingInfo');
                infoDiv.style.display = 'block';
                infoDiv.innerHTML = `
                    <div style="padding: 12px; background: rgba(11, 128, 122, 0.1); border-left: 3px solid #0b807a; margin: 10px 0;">
                        ✓ Loaded graphics mapping: ${validCount} valid mappings
                        ${invalidCount > 0 ? `<br><span style="color: var(--text-muted);">⚠ ${invalidCount} equipment paths not found in main CSV</span>` : ''}
                    </div>
                `;

                showToast(`Loaded ${validCount} graphics mappings`, 'success');

            } catch (error) {
                console.error('Error loading graphics mapping:', error);
                showToast('Error loading graphics mapping: ' + error.message, 'error');
            }
        }

        async function handleGraphicsFolderSelection(event) {
            if (!appData) {
                showToast('Please load a CSV file first', 'error');
                return;
            }

            const files = event.target.files;
            if (!files || files.length === 0) {
                return;
            }

            try {
                showToast('Scanning for PX files...', 'info');

                // Filter for .px files and extract folder info
                const pxFiles = [];
                let folderName = '';

                for (let i = 0; i < files.length; i++) {
                    const file = files[i];

                    if (file.name.toLowerCase().endsWith('.px')) {
                        // Extract folder name from first file's path
                        if (!folderName && file.webkitRelativePath) {
                            const parts = file.webkitRelativePath.split('/');
                            folderName = parts[0] || 'Selected Folder';
                        }

                        // Use webkitRelativePath for full path, or just name as fallback
                        const filePath = file.webkitRelativePath || file.name;

                        pxFiles.push({
                            name: file.name,
                            path: filePath,
                            file: file  // Direct File object instead of handle
                        });
                    }
                }

                if (pxFiles.length === 0) {
                    showToast('No .px files found in the selected folder', 'error');
                    return;
                }

                showToast(`Found ${pxFiles.length} PX files. Processing...`, 'info');

                // Process each PX file
                const results = [];
                for (const fileInfo of pxFiles) {
                    const result = await processPXFile(fileInfo);
                    if (result) {
                        results.push(result);
                    }
                }

                // Store graphics data
                graphicsData = {
                    folderName,
                    pxFiles,
                    // Keep graphics with issues OR with direct equipment references (floor plans)
                    results: results.filter(r =>
                        r.issues.length > 0 ||
                        (r.equipmentMatch && r.equipmentMatch.source === 'direct-reference')
                    )
                };

                // Display results
                displayGraphicsResults();
                showToast(`Processed ${results.length} graphics. Found ${graphicsData.results.length} with issues or equipment matches.`, 'success');

            } catch (error) {
                console.error('Error processing folder:', error);
                showToast('Error scanning folder: ' + error.message, 'error');
            }
        }

        async function processPXFile(fileInfo) {
            try {
                const file = fileInfo.file;
                const content = await file.text();

                // Parse XML
                const parser = new DOMParser();
                const doc = parser.parseFromString(content, 'text/xml');

                // Check for parse errors
                const parseError = doc.querySelector('parsererror');
                if (parseError) {
                    return {
                        filename: fileInfo.name,
                        path: fileInfo.path,
                        error: 'XML parse error',
                        issues: [{
                            type: 'error',
                            message: 'Failed to parse XML'
                        }]
                    };
                }

                // Extract point references
                const pointRefs = extractPointReferences(doc, fileInfo.name);

                // Extract equipment references from PxInclude (for floor plans, etc.)
                const equipmentRefs = [];
                const equipmentCounts = new Map(); // Track duplicates
                const pxIncludes = doc.querySelectorAll('PxInclude');
                pxIncludes.forEach(include => {
                    const variables = include.getAttribute('variables');
                    if (variables) {
                        // Look for ANY variable containing station: or slot: paths (equipment=, VAV=, AHU=, etc.)
                        const matches = variables.matchAll(/(\w+)=s:(station[^&\s]+|slot[^&\s]+|[^&\s]*(?:station|slot)[^&\s]*)/gi);
                        for (const match of matches) {
                            const encodedPath = match[2];
                            const decodedPath = decodePxPath(encodedPath);
                            // Remove station:|slot:, station:, or slot: prefixes
                            let cleanPath = decodedPath
                                .replace(/^station:\|slot:/, '')
                                .replace(/^station:/, '')
                                .replace(/^slot:/, '');

                            // Only add paths that look like equipment paths (contain /Drivers/ or similar structure)
                            if (cleanPath.includes('/') && !cleanPath.includes('points/')) {
                                equipmentRefs.push(cleanPath);
                                equipmentCounts.set(cleanPath, (equipmentCounts.get(cleanPath) || 0) + 1);
                            }
                        }
                    }
                });

                // Validate point references against CSV data
                const validation = validatePointReferences(pointRefs);

                // Match to equipment
                let equipmentMatch = null;

                // If mapping CSV is loaded, ONLY use mapping (no fallback)
                if (graphicsMappingData) {
                    // Get PX filename without extension
                    const pxName = fileInfo.name.replace(/\.px$/i, '');

                    if (graphicsMappingData.has(pxName)) {
                        const mappedPath = graphicsMappingData.get(pxName);
                        const matchedDevice = appData.devices.find(d => d.path === mappedPath);

                        if (matchedDevice) {
                            equipmentMatch = {
                                bestMatch: matchedDevice.path,
                                confidence: 100,
                                score: matchedDevice.points ? matchedDevice.points.length : 0,
                                total: matchedDevice.points ? matchedDevice.points.length : 0,
                                source: 'csv-mapping'
                            };
                        }
                    } else {
                        // Not in mapping - set to null (no match)
                        equipmentMatch = {
                            bestMatch: null,
                            confidence: 0,
                            score: 0,
                            total: 0,
                            source: 'not-mapped'
                        };
                    }
                } else {
                    // No mapping CSV loaded - use auto-detection
                    equipmentMatch = matchToEquipment(pointRefs);

                    // If equipment references found, try direct matching first
                    if (equipmentRefs.length > 0 && appData.devices) {
                        const directMatch = appData.devices.find(d =>
                            equipmentRefs.some(ref =>
                                d.path === ref ||
                                d.path.includes(ref) ||
                                ref.includes(d.path.split('/').pop())
                            )
                        );
                        if (directMatch) {
                            equipmentMatch = {
                                bestMatch: directMatch.path,
                                confidence: 100,
                                score: directMatch.points ? directMatch.points.length : 0,
                                total: directMatch.points ? directMatch.points.length : 0,
                                source: 'direct-reference'
                            };
                        }
                    }
                }

                // Collect issues
                const issues = [];

                // Add invalid point reference errors (points on graphic that don't exist in station)
                validation.missing.forEach(point => {
                    issues.push({
                        type: 'error',
                        message: `Invalid point reference: ${point.pointName} (not found in station)`,
                        pointName: point.pointName
                    });
                });

                // Add duplicate warnings
                validation.duplicates.forEach(point => {
                    issues.push({
                        type: 'warning',
                        message: `Duplicate binding: ${point.pointName} (${point.count}x)`,
                        pointName: point.pointName
                    });
                });

                // Add duplicate equipment warnings
                equipmentCounts.forEach((count, equipPath) => {
                    if (count > 1) {
                        issues.push({
                            type: 'warning',
                            message: `Duplicate equipment reference: ${equipPath} (${count}x)`,
                            equipmentPath: equipPath
                        });
                    }
                });

                // Add wrong equipment warnings
                validation.wrongEquipment.forEach(point => {
                    issues.push({
                        type: 'warning',
                        message: `Possible wrong equipment: ${point.pointName} (found in ${point.foundInDevice})`,
                        pointName: point.pointName,
                        foundInDevice: point.foundInDevice
                    });
                });

                // Add completeness check - points in equipment not shown on graphic
                if (equipmentMatch.bestMatch) {
                    const matchedDevice = appData.devices.find(d => d.path === equipmentMatch.bestMatch);
                    if (matchedDevice && matchedDevice.points) {
                        const graphicPoints = new Set(pointRefs.map(ref => ref.pointName));
                        const notOnGraphic = matchedDevice.points
                            .filter(point => !graphicPoints.has(point.name))
                            .map(point => point.name);

                        if (notOnGraphic.length > 0) {
                            issues.push({
                                type: 'info',
                                message: `Missing points: ${notOnGraphic.length} points in equipment not shown on graphic`,
                                pointNames: notOnGraphic, // Keep all points
                                totalCount: notOnGraphic.length
                            });
                        }
                    }
                }

                return {
                    filename: fileInfo.name,
                    path: fileInfo.path,
                    pointRefs,
                    equipmentMatch,
                    validation,
                    issues
                };

            } catch (error) {
                console.error(`Error processing ${fileInfo.name}:`, error);
                return {
                    filename: fileInfo.name,
                    path: fileInfo.path,
                    error: error.message,
                    issues: [{
                        type: 'error',
                        message: `Error: ${error.message}`
                    }]
                };
            }
        }

        function extractPointReferences(doc, filename) {
            const pointRefs = [];
            const pointCounts = new Map(); // Track duplicates

            // Extract from ValueBinding elements
            const valueBindings = doc.querySelectorAll('ValueBinding');
            valueBindings.forEach((binding, index) => {
                const ord = binding.getAttribute('ord');
                if (ord) {
                    const parsed = parseORD(ord, 'ValueBinding', index);
                    if (parsed) {
                        const key = parsed.fullORD || parsed.pointName;
                        pointCounts.set(key, (pointCounts.get(key) || 0) + 1);
                        pointRefs.push(parsed);
                    }
                }
            });

            // Extract from PxInclude elements with variables
            const pxIncludes = doc.querySelectorAll('PxInclude');
            pxIncludes.forEach((include, index) => {
                const variables = include.getAttribute('variables');
                if (variables && variables.includes('point=')) {
                    // Parse URL-encoded point path
                    const match = variables.match(/point=s:([^&\s]+)/);
                    if (match) {
                        const encodedPath = match[1];
                        const decodedPath = decodePxPath(encodedPath);

                        // Only add slot: prefix if not already present in decoded path
                        const fullPath = decodedPath.startsWith('slot:')
                            ? decodedPath
                            : 'slot:' + decodedPath;

                        const parsed = parseORD(fullPath, 'PxInclude', index);
                        if (parsed) {
                            const key = parsed.fullORD || parsed.pointName;
                            pointCounts.set(key, (pointCounts.get(key) || 0) + 1);
                            pointRefs.push(parsed);
                        }
                    }
                }
            });

            // Add duplicate count to each point reference
            pointRefs.forEach(ref => {
                const key = ref.fullORD || ref.pointName;
                ref.duplicateCount = pointCounts.get(key) || 1;
            });

            return pointRefs;
        }

        function decodePxPath(encoded) {
            return encoded
                // Handle double-encoded space first (sometimes appears as $2420)
                .replace(/\$2420/gi, ' ')
                // Standard URL encodings
                .replace(/\$3a/gi, ':')
                .replace(/\$2f/gi, '/')
                .replace(/\$2d/gi, '-')
                .replace(/\$20/gi, ' ')
                .replace(/\$2e/gi, '.')
                .replace(/\$2c/gi, ',')
                .replace(/\$5f/gi, '_')
                .replace(/\$28/gi, '(')
                .replace(/\$29/gi, ')')
                // Fallback: decode any remaining $XX hex codes
                .replace(/\$([0-9A-Fa-f]{2})/g, (match, hex) => {
                    try {
                        return String.fromCharCode(parseInt(hex, 16));
                    } catch {
                        return match; // Leave unchanged if decode fails
                    }
                });
        }

        function parseORD(ordPath, sourceType, index) {
            if (!ordPath) return null;

            // Remove station: prefix if present
            let path = ordPath.replace(/^station:\|?/, '');

            // Check if it's a point reference (contains /points/ or ends with points/POINT_NAME)
            if (!path.includes('/points/') && !path.match(/points\/[^\/]+$/)) {
                return null; // Not a point reference
            }

            // Check if relativized (starts with slot:)
            const isRelativized = path.startsWith('slot:');

            // Remove slot: prefix if present
            path = path.replace(/^slot:/, '');

            // Extract point name (everything after last /points/ or points/)
            // Handle both /points/ and points/ (PxInclude paths may not have leading slash)
            const pointsMatch = path.match(/\/?points\/(.+)$/);
            if (!pointsMatch) return null;

            const pointName = pointsMatch[1];

            // Extract equipment path (everything before /points/ or points/)
            let equipmentPath = null;
            if (!isRelativized) {
                const equipMatch = path.match(/^(.+?)\/?points\//);
                if (equipMatch) {
                    equipmentPath = equipMatch[1];
                }
            }

            return {
                fullORD: ordPath,
                pointName,
                equipmentPath,
                isRelativized,
                sourceType,
                sourceIndex: index
            };
        }

        function validatePointReferences(pointRefs) {
            const missing = [];
            const duplicates = [];
            const wrongEquipment = [];
            const found = [];

            // Create a map of all points in CSV data by point name
            const pointsByName = new Map();
            appData.devices.forEach(device => {
                if (device.points) {
                    device.points.forEach(point => {
                        const pointName = point.name; // Extract name from point object
                        if (!pointsByName.has(pointName)) {
                            pointsByName.set(pointName, []);
                        }
                        pointsByName.get(pointName).push(device.path);
                    });
                }
            });

            // Check each point reference
            const checked = new Set(); // Track which points we've already validated
            pointRefs.forEach(ref => {
                const key = ref.fullORD || ref.pointName;
                if (checked.has(key)) return; // Skip duplicates for validation
                checked.add(key);

                const devicesWithPoint = pointsByName.get(ref.pointName);

                if (!devicesWithPoint || devicesWithPoint.length === 0) {
                    // Point not found anywhere
                    missing.push(ref);
                } else if (ref.equipmentPath) {
                    // Full ORD - check if point exists in specified equipment
                    if (!devicesWithPoint.includes(ref.equipmentPath)) {
                        // Point exists but in different equipment
                        wrongEquipment.push({
                            ...ref,
                            foundInDevice: devicesWithPoint[0] // Show first match
                        });
                    } else {
                        found.push(ref);
                    }
                } else {
                    // Relativized - point exists somewhere (will use heuristic matching)
                    found.push(ref);
                }

                // Check for duplicates
                if (ref.duplicateCount > 1) {
                    duplicates.push({
                        ...ref,
                        count: ref.duplicateCount
                    });
                }
            });

            return {
                missing,
                duplicates,
                wrongEquipment,
                found
            };
        }

        function matchToEquipment(pointRefs) {
            // Extract unique point names from references
            const uniquePoints = [...new Set(pointRefs.map(ref => ref.pointName))];

            if (uniquePoints.length === 0) {
                return {
                    bestMatch: null,
                    confidence: 0,
                    score: 0,
                    total: 0
                };
            }

            // Score each device by counting how many of the graphic's points exist in that device
            let bestMatch = null;
            let bestScore = 0;

            appData.devices.forEach(device => {
                if (!device.points || device.points.length === 0) return;

                const matchCount = uniquePoints.filter(pointName =>
                    device.points.some(point => point.name === pointName)
                ).length;

                if (matchCount > bestScore) {
                    bestScore = matchCount;
                    bestMatch = device;
                }
            });

            const confidence = bestMatch ? (bestScore / uniquePoints.length) * 100 : 0;

            return {
                bestMatch: bestMatch ? bestMatch.path : null,
                confidence: Math.round(confidence),
                score: bestScore,
                total: uniquePoints.length
            };
        }

        function displayGraphicsResults() {
            const folderInfo = document.getElementById('graphicsFolderInfo');
            const resultsContainer = document.getElementById('graphicsResults');

            if (!graphicsData) {
                folderInfo.style.display = 'none';
                resultsContainer.innerHTML = '';
                return;
            }

            // Show folder info
            folderInfo.style.display = 'block';
            folderInfo.innerHTML = `
                <div class="folder-info">
                    <div class="folder-info-text">
                        <div class="folder-name">📁 ${graphicsData.folderName}</div>
                        <div class="folder-stats">${graphicsData.pxFiles.length} PX files scanned</div>
                    </div>
                </div>
            `;

            // Show results
            if (graphicsData.results.length === 0) {
                resultsContainer.innerHTML = `
                    <div class="summary-card" style="background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%);">
                        <h3 style="margin: 0;">✅ No Issues Found</h3>
                        <p style="margin-top: 10px; opacity: 0.9;">All graphics have valid point references!</p>
                    </div>
                `;
                return;
            }

            let html = `
                <div class="summary-card">
                    <h3>Results Summary</h3>
                    <div class="summary-stats">
                        <div class="stat">
                            <div class="stat-value">${graphicsData.results.length}</div>
                            <div class="stat-label">Graphics with Issues</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value">${graphicsData.results.reduce((sum, r) => sum + r.issues.filter(i => i.type === 'error').length, 0)}</div>
                            <div class="stat-label">Missing Points</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value">${graphicsData.results.reduce((sum, r) => sum + r.issues.filter(i => i.type === 'warning').length, 0)}</div>
                            <div class="stat-label">Warnings</div>
                        </div>
                    </div>
                </div>
            `;

            // Display each graphic with issues
            graphicsData.results.forEach(result => {
                const match = result.equipmentMatch;
                let confidenceClass = 'confidence-low';
                let confidenceLabel = 'Low';

                if (match.confidence >= 80) {
                    confidenceClass = 'confidence-high';
                    confidenceLabel = 'High';
                } else if (match.confidence >= 50) {
                    confidenceClass = 'confidence-medium';
                    confidenceLabel = 'Medium';
                }

                html += `
                    <div class="graphic-item">
                        <div class="graphic-header">
                            <div>
                                <div class="graphic-title">${result.filename}</div>
                                <div class="graphic-path">${result.path}</div>
                            </div>
                        </div>
                `;

                // Show equipment match
                if (match.bestMatch) {
                    // Determine source badge
                    let sourceBadge = '';
                    if (match.source === 'csv-mapping') {
                        sourceBadge = '<span style="background: #0b807a; color: white; padding: 2px 8px; border-radius: 3px; font-size: 11px; margin-left: 8px; font-weight: 500;">CSV Mapped</span>';
                    } else if (match.source === 'direct-reference') {
                        sourceBadge = '<span style="background: #4db864; color: white; padding: 2px 8px; border-radius: 3px; font-size: 11px; margin-left: 8px; font-weight: 500;">Auto-detected</span>';
                    } else {
                        sourceBadge = '<span style="background: #95a5a6; color: white; padding: 2px 8px; border-radius: 3px; font-size: 11px; margin-left: 8px; font-weight: 500;">Heuristic</span>';
                    }

                    html += `
                        <div class="equipment-match">
                            <span class="match-label">Equipment Match:</span>
                            <span class="match-device">${match.bestMatch}</span>
                            ${sourceBadge}
                            <span class="confidence-badge ${confidenceClass}">${confidenceLabel} ${match.confidence}%</span>
                            <span style="color: var(--text-muted); font-size: 12px;">(${match.score}/${match.total} points)</span>
                        </div>
                    `;
                } else {
                    // Check if this is a "not-mapped" case
                    let noMatchMessage = 'No match found';
                    let noMatchBadge = '';
                    if (match && match.source === 'not-mapped') {
                        noMatchMessage = 'Not mapped';
                        noMatchBadge = '<span style="background: #7f8c8d; color: white; padding: 2px 8px; border-radius: 3px; font-size: 11px; margin-left: 8px; font-weight: 500;">Not in CSV</span>';
                    }

                    html += `
                        <div class="equipment-match">
                            <span class="match-label">Equipment Match:</span>
                            <span style="color: var(--text-muted);">${noMatchMessage}</span>
                            ${noMatchBadge}
                        </div>
                    `;
                }

                // Show issues
                html += '<div class="issue-list">';
                result.issues.forEach((issue, index) => {
                    let issueClass = 'info';
                    let icon = 'ℹ️';

                    if (issue.type === 'error') {
                        issueClass = 'error';
                        icon = '❌';
                    } else if (issue.type === 'warning') {
                        issueClass = 'warning';
                        icon = '⚠️';
                    }

                    // Check if this is an expandable info message with point names
                    const isExpandable = issue.type === 'info' && issue.pointNames && issue.pointNames.length > 0;
                    const expandableClass = isExpandable ? 'expandable' : '';
                    const issueId = `issue-${result.filename.replace(/[^a-z0-9]/gi, '-')}-${index}`;

                    html += `
                        <div class="issue-item ${issueClass} ${expandableClass}" ${isExpandable ? `onclick="toggleIssueDetail('${issueId}')"` : ''}>
                            <span class="issue-icon">${icon}</span>
                            <span class="issue-text">${issue.message}</span>
                        </div>
                    `;

                    // Add expandable detail section if applicable
                    if (isExpandable) {
                        html += `
                            <div class="missing-points-detail" id="${issueId}">
                                <div style="color: var(--text-secondary); margin-bottom: 8px;">
                                    All ${issue.totalCount} missing points:
                                </div>
                                <div class="missing-points-list">
                                    ${issue.pointNames.map(point =>
                                        `<span class="missing-point">${point}</span>`
                                    ).join('')}
                                </div>
                            </div>
                        `;
                    }
                });
                html += '</div>'; // Close issue-list

                html += '</div>'; // Close graphic-item
            });

            resultsContainer.innerHTML = html;
        }

        // Toggle expandable issue detail
        function toggleIssueDetail(issueId) {
            const issueItem = document.querySelector(`[onclick*="${issueId}"]`);
            const detailElement = document.getElementById(issueId);

            if (issueItem && detailElement) {
                issueItem.classList.toggle('expanded');
                detailElement.classList.toggle('visible');
            }
        }

        // === HELP SYSTEM ===

        const helpContent = {
            'station-tree': `
                <h1>Tree View</h1>
                <p>The Tree View provides a hierarchical visualization of your Niagara station structure, allowing you to browse equipment, devices, and points.</p>

                <h2>Getting Started</h2>
                <ol class="help-steps">
                    <li><strong>Load Station CSV:</strong> Click "Load Station CSV" and select your exported CSV file from Niagara. The CSV should contain Slot Path and Facets columns.</li>
                    <li><strong>Navigate the Tree:</strong> Click expand arrows to open folders and view equipment. Equipment items are marked with a CPU icon.</li>
                    <li><strong>View Point Details:</strong> Click on an equipment item to view its details in the right panel.</li>
                </ol>

                <h2>Key Features</h2>
                <h3>Point Type Icons</h3>
                <p>Each point is displayed with a colored circle icon indicating its type:</p>
                <ul>
                    <li><strong>Green (B)</strong> - Boolean points</li>
                    <li><strong>Purple (N)</strong> - Numeric points</li>
                    <li><strong>Yellow (E)</strong> - Enum points</li>
                    <li><strong>Grey (S)</strong> - String points</li>
                </ul>

                <h3>Search Functionality</h3>
                <p>Use the search bar to filter devices and points by name. The tree automatically expands to show matching items.</p>

                <h3>Expand/Collapse Controls</h3>
                <p>Use "Expand All" and "Collapse All" buttons to quickly open or close all tree nodes.</p>

                <h3>Exclude Items</h3>
                <p>Click the eye icon next to any equipment or folder to exclude it from templates and exports. Excluded items appear dimmed.</p>

                <h3>Copy ORDs</h3>
                <p>Click any point in the tree to copy its relativized ORD (Object Reference Descriptor) to clipboard for use in Niagara graphics.</p>

                <div class="help-info-box">
                    <strong>💡 Tip:</strong>
                    Points in the detail panel are also clickable to copy their ORDs. The white text with colored type icons makes them easy to identify.
                </div>

                <h2>Detail Panel</h2>
                <p>When you click equipment, the detail panel shows:</p>
                <ul>
                    <li>Template information (how many similar equipment exist)</li>
                    <li>All devices in the same template (click to navigate)</li>
                    <li>Complete list of points with type icons (click to copy ORD)</li>
                    <li>Partial template matches with differences highlighted</li>
                </ul>
            `,

            'station-templates': `
                <h1>Templates View</h1>
                <p>Templates automatically identifies equipment with matching point structures, helping you standardize your station configuration.</p>

                <h2>How It Works</h2>
                <p>The application analyzes all equipment in your station and groups those with identical point names and structures into templates.</p>

                <h2>Using Templates</h2>
                <ol class="help-steps">
                    <li><strong>Review Templates:</strong> Each template shows how many devices share that structure and what percentage of your total equipment they represent.</li>
                    <li><strong>Select Equipment:</strong> Check or uncheck individual devices within each template. Use "✓ All" or "✗ All" buttons for quick selection.</li>
                    <li><strong>View Points:</strong> Click the expand button (▶) to see all points in the template. Click any point to copy its ORD.</li>
                    <li><strong>Export for Reflow:</strong> Once you've selected your equipment, export a Reflow file for schedule generation.</li>
                </ol>

                <h2>Key Features</h2>
                <h3>Template Statistics</h3>
                <p>The summary card shows:</p>
                <ul>
                    <li>Total unique templates found</li>
                    <li>Total devices across all templates</li>
                    <li>Average devices per template</li>
                </ul>

                <h3>Point Type Icons</h3>
                <p>Expanded point lists show colored circle icons indicating each point's type (Boolean, Numeric, Enum, String).</p>

                <h3>Equipment Selection</h3>
                <p>Checkboxes remember your selections across sessions, allowing you to build custom equipment sets for Reflow export.</p>

                <div class="help-info-box">
                    <strong>💡 Pro Tip:</strong>
                    Templates with high device counts are excellent candidates for standardization. Consider using these as your reference templates for new equipment.
                </div>
            `,

            'station-comparison': `
                <h1>Comparison View</h1>
                <p>Compare two station CSV files to identify differences in equipment and point configurations.</p>

                <h2>How to Use</h2>
                <ol class="help-steps">
                    <li><strong>Load Primary CSV:</strong> Load your first (reference) station CSV as usual.</li>
                    <li><strong>Load Comparison CSV:</strong> Click "Load Comparison CSV" and select the second file to compare.</li>
                    <li><strong>View Results:</strong> The comparison report shows equipment found only in primary, only in secondary, or in both files.</li>
                </ol>

                <h2>Comparison Report Sections</h2>
                <h3>Only in Primary File</h3>
                <p>Equipment and points that exist in your reference file but not in the comparison file. These may represent:</p>
                <ul>
                    <li>New equipment added</li>
                    <li>Equipment that was removed in the second station</li>
                    <li>Configuration differences</li>
                </ul>

                <h3>Only in Secondary File</h3>
                <p>Equipment and points found in the comparison file but missing from the primary. Useful for identifying:</p>
                <ul>
                    <li>Equipment removed from primary</li>
                    <li>New equipment in secondary</li>
                    <li>Inconsistencies between stations</li>
                </ul>

                <h3>In Both Files</h3>
                <p>Equipment that exists in both stations, showing identical configurations.</p>

                <div class="help-warning-box">
                    <strong>⚠️ Note:</strong>
                    Comparison is based on equipment paths and point names. Minor differences in facets or configuration won't show equipment as different if the structure matches.
                </div>
            `,

            'graphics-review': `
                <h1>Graphics Review</h1>
                <p>Verify that all equipment has corresponding graphics views by uploading a graphics mapping CSV.</p>

                <h2>Requirements</h2>
                <p>Before using Graphics Review, you need two files:</p>
                <ol>
                    <li><strong>Station CSV:</strong> Already loaded with your equipment data</li>
                    <li><strong>Graphics Mapping CSV:</strong> Export from Niagara using the BQL query shown below</li>
                </ol>

                <h3>BQL Query for Graphics Mapping</h3>
                <pre><code>station:|slot:/|bql:select slotPath.toString(), view.name.toString() from control:EquipmentPoints</code></pre>
                <p>This query exports equipment paths and their associated view names.</p>

                <h2>How to Use</h2>
                <ol class="help-steps">
                    <li><strong>Load Graphics CSV:</strong> Click "Load Graphics Mapping CSV" and select your exported BQL results.</li>
                    <li><strong>Review Coverage:</strong> The report shows which equipment has graphics and which doesn't.</li>
                    <li><strong>Identify Missing Graphics:</strong> Equipment without graphics is highlighted for follow-up.</li>
                </ol>

                <h2>Report Sections</h2>
                <h3>Coverage Summary</h3>
                <ul>
                    <li>Total equipment count</li>
                    <li>Equipment with graphics (count and percentage)</li>
                    <li>Missing graphics (count and percentage)</li>
                </ul>

                <h3>Equipment Lists</h3>
                <p>Detailed lists show:</p>
                <ul>
                    <li>Equipment with graphics (including view names)</li>
                    <li>Equipment missing graphics (flagged for creation)</li>
                </ul>

                <div class="help-info-box">
                    <strong>💡 Live Connect Option:</strong>
                    Use "Live Connect Graphics" button to connect directly to a Niagara station and pull graphics data in real-time. Requires CORS to be enabled in Niagara.
                </div>
            `,

            'comm-typo': `
                <h1>Point Name Typo Checker</h1>
                <p>Automatically detects potential typos in point names by comparing against common naming patterns and finding unusual variations.</p>

                <h2>How It Works</h2>
                <p>The checker analyzes all point names in your station and:</p>
                <ul>
                    <li>Identifies names that are very similar but not identical</li>
                    <li>Groups similar names together</li>
                    <li>Flags potential typos based on frequency and patterns</li>
                    <li>Highlights the differences between similar names</li>
                </ul>

                <h2>Using the Checker</h2>
                <ol class="help-steps">
                    <li><strong>Load Station CSV:</strong> Make sure your station data is loaded.</li>
                    <li><strong>Run Check:</strong> Click "Run Typo Check" to analyze all point names.</li>
                    <li><strong>Review Results:</strong> Examine grouped results showing similar names.</li>
                    <li><strong>Verify Issues:</strong> Determine which are actual typos vs. intentional variations.</li>
                </ol>

                <h2>Understanding Results</h2>
                <p>Results are grouped by similarity. Each group shows:</p>
                <ul>
                    <li>The point names that are similar</li>
                    <li>How many times each variation appears</li>
                    <li>Character-by-character comparison</li>
                </ul>

                <div class="help-warning-box">
                    <strong>⚠️ Important:</strong>
                    Not all flagged items are typos. Some variations may be intentional based on equipment type, location, or function. Manual review is recommended.
                </div>
            `,

            'comm-facet': `
                <h1>Facet Checker</h1>
                <p>Review and export point facet configurations to verify proper setup of units, ranges, and other point properties.</p>

                <h2>What are Facets?</h2>
                <p>Facets in Niagara are metadata that describe point properties such as:</p>
                <ul>
                    <li>Engineering units (°F, %, PSI, etc.)</li>
                    <li>Min/Max ranges</li>
                    <li>Precision (decimal places)</li>
                    <li>Display text for boolean values</li>
                    <li>Enum ranges</li>
                </ul>

                <h2>Using Facet Checker</h2>
                <ol class="help-steps">
                    <li><strong>Load CSV with Facets:</strong> Your station CSV must include a Facets column (exported from Niagara).</li>
                    <li><strong>Review Points:</strong> Browse through points and their facet configurations.</li>
                    <li><strong>Export Report:</strong> Generate a CSV report of all facets for documentation or analysis.</li>
                </ol>

                <h2>Export Format</h2>
                <p>The exported facet report includes:</p>
                <ul>
                    <li>Point path</li>
                    <li>Point name</li>
                    <li>Complete facet string</li>
                    <li>Parsed facet properties</li>
                </ul>

                <div class="help-info-box">
                    <strong>💡 Use Case:</strong>
                    Facet reports are valuable for standardization audits, template creation, and verifying consistent configuration across similar equipment.
                </div>
            `,

            'comm-history': `
                <h1>History Extension Check</h1>
                <p>Verify that history extensions are properly configured and enabled. Identifies potentially missed extensions by pattern matching.</p>

                <h2>Requirements</h2>
                <p>Export history extension data from Niagara using this BQL query:</p>
                <pre><code>station:|slot:/Drivers|bql:select parent.slotPath as 'Slot Path', name as 'History Extension', enabled as 'Enabled' from baja:Component where (name = 'NumericInterval' or name = 'NumericCov' or name = 'BooleanInterval' or name = 'BooleanCov' or name = 'EnumInterval' or name = 'EnumCov' or name = 'StringInterval' or name = 'StringCov')</code></pre>

                <h2>How to Use</h2>
                <ol class="help-steps">
                    <li><strong>Load History CSV:</strong> Upload the CSV exported from the BQL query above.</li>
                    <li><strong>Run Check:</strong> Click "Run History Check" to analyze the data.</li>
                    <li><strong>Review Results:</strong> Examine disabled extensions and potentially missed patterns.</li>
                </ol>

                <h2>What It Checks</h2>
                <h3>Disabled Extensions</h3>
                <p>Lists all history extensions that exist but have <code>enabled = false</code>. These extensions are configured but not actively collecting data.</p>

                <h3>Potentially Missed Extensions</h3>
                <p>Uses pattern detection to find points that might need history extensions:</p>
                <ul>
                    <li>Groups points by name (e.g., all "SpaceTemp" points)</li>
                    <li>If 80% or more have history extensions, flags the ones without</li>
                    <li>Shows coverage percentage to indicate confidence</li>
                </ul>

                <div class="help-info-box">
                    <strong>💡 Pattern Detection:</strong>
                    The 80% threshold helps identify systematic patterns. If most similar points have history, the outliers likely need it too.
                </div>
            `,

            'comm-alarm': `
                <h1>Alarm Extension Check</h1>
                <p>Verify that alarm extensions are properly configured and enabled. Identifies potentially missed extensions by pattern matching.</p>

                <h2>Requirements</h2>
                <p>Export alarm extension data from Niagara using this BQL query:</p>
                <pre><code>station:|slot:/Drivers|bql:select parent.slotPath as 'Point', name as 'Alarm Extension', enabled as 'Enabled' from baja:Component where (name = 'OutOfRangeAlarmExt' or name = 'FloatLimitAlarmExt' or name = 'StringChangeOfValueAlarmExt' or name = 'BooleanChangeOfStateAlarmExt' or name = 'BooleanCommandFailureAlarmExt' or name = 'EnumChangeOfStateAlarmExt' or name = 'EnumCommandFailureAlarmExt' or name = 'NumericChangeOfStateAlarmExt' or name = 'StatusAlarmExt')</code></pre>

                <h2>How to Use</h2>
                <ol class="help-steps">
                    <li><strong>Load Alarm CSV:</strong> Upload the CSV exported from the BQL query above.</li>
                    <li><strong>Run Check:</strong> Click "Run Alarm Check" to analyze the data.</li>
                    <li><strong>Review Results:</strong> Examine disabled extensions and potentially missed patterns.</li>
                </ol>

                <h2>What It Checks</h2>
                <h3>Disabled Extensions</h3>
                <p>Lists all alarm extensions that exist but have <code>enabled = false</code>. These alarms are configured but not actively monitoring.</p>

                <h3>Potentially Missed Extensions</h3>
                <p>Uses pattern detection identical to History Check:</p>
                <ul>
                    <li>Groups points by name across all equipment</li>
                    <li>If 80% or more have alarm extensions, flags the ones without</li>
                    <li>Shows coverage percentage and similar equipment count</li>
                </ul>

                <div class="help-warning-box">
                    <strong>⚠️ Review Required:</strong>
                    Not all flagged points necessarily need alarms. Use engineering judgment to determine which points truly require alarming based on system requirements.
                </div>
            `,

            'comm-checkout': `
                <h1>Commissioning Checkout Report</h1>
                <p>Generate a comprehensive, printable commissioning report that includes equipment, points, history extensions, and alarm extensions.</p>

                <h2>Report Components</h2>
                <p>The checkout report combines multiple data sources into a single document:</p>
                <ul>
                    <li>Equipment list with point counts and template groupings</li>
                    <li>Complete point details with types for each equipment</li>
                    <li>History extension configuration (if loaded)</li>
                    <li>Alarm extension configuration (if loaded)</li>
                    <li>Optional company logo</li>
                </ul>

                <h2>How to Generate</h2>
                <ol class="help-steps">
                    <li><strong>Load Data:</strong> Ensure station CSV is loaded. Optionally load history and alarm CSVs.</li>
                    <li><strong>Upload Logo (Optional):</strong> Add your company logo for a professional header.</li>
                    <li><strong>Build Report:</strong> Click "Build Report" to analyze equipment and create the review list.</li>
                    <li><strong>Review Equipment:</strong> Uncheck any items that shouldn't be included (false positives, test equipment, etc.).</li>
                    <li><strong>Generate Report:</strong> Click "Generate Report" to create the final document.</li>
                    <li><strong>Export:</strong> Use "Export Report" to open the print dialog and save as PDF.</li>
                </ol>

                <h2>Report Features</h2>
                <h3>Equipment Summary</h3>
                <p>Each equipment shows:</p>
                <ul>
                    <li>Equipment name and path</li>
                    <li>Number of similar equipment (template matching)</li>
                    <li>Total point count</li>
                    <li>Complete point list with types</li>
                </ul>

                <h3>Extension Tables</h3>
                <p>If history/alarm CSVs are loaded, tables show:</p>
                <ul>
                    <li>Point path</li>
                    <li>Extension type</li>
                    <li>Enabled status (color-coded)</li>
                </ul>

                <h3>Data Reuse</h3>
                <p>If you've already uploaded history/alarm CSVs in other commissioning tabs, the report automatically uses that data—no need to upload again!</p>

                <div class="help-info-box">
                    <strong>💡 Professional Output:</strong>
                    The report is styled for printing and PDF generation. Page breaks are optimized, and tables are formatted for easy reading.
                </div>
            `,

            'reflow-builder': `
                <h1>Reflow Builder</h1>
                <p>Generate Niagara Reflow schedule templates from selected equipment, with configurable naming and timing intervals.</p>

                <h2>What is Reflow?</h2>
                <p>Reflow is a Niagara tool for creating schedules in bulk. This builder generates the input files Reflow needs based on your equipment selection.</p>

                <h2>How to Use</h2>
                <ol class="help-steps">
                    <li><strong>Select Equipment:</strong> Go to Templates view and check the equipment you want to include.</li>
                    <li><strong>Switch to Reflow:</strong> Navigate to Reflow tab → Reflow Builder.</li>
                    <li><strong>Configure Templates:</strong> For each template, enter:
                        <ul>
                            <li>Schedule name pattern (e.g., "OccSchedule" or "$name_Schedule")</li>
                            <li>Time intervals (e.g., "7:00-18:00")</li>
                        </ul>
                    </li>
                    <li><strong>Export:</strong> Click "Export Reflow File" to download the JSON file.</li>
                    <li><strong>Import to Niagara:</strong> Use the Reflow module in Niagara to import and process the file.</li>
                </ol>

                <h2>Naming Patterns</h2>
                <p>Use special tokens in schedule names:</p>
                <ul>
                    <li><code>$name</code> - Replaced with equipment name</li>
                    <li><code>$template</code> - Replaced with template number</li>
                    <li>Static text - Used as-is for all equipment</li>
                </ul>

                <h3>Examples</h3>
                <ul>
                    <li><code>OccSchedule</code> → All get "OccSchedule"</li>
                    <li><code>$name_Schedule</code> → "AHU_01_Schedule", "AHU_02_Schedule", etc.</li>
                    <li><code>Template_$template_Occ</code> → "Template_1_Occ", "Template_1_Occ", etc.</li>
                </ul>

                <div class="help-info-box">
                    <strong>💡 Best Practice:</strong>
                    Test with a small subset first. Export 2-3 equipment, import to Niagara, verify the results, then scale up to your full station.
                </div>
            `,

            'reflow-regex': `
                <h1>Reflow Regex Generator</h1>
                <p>Generate regular expression patterns for Reflow point processing and matching.</p>

                <h2>Purpose</h2>
                <p>When using Reflow to bulk-modify points or create objects, you often need regex patterns to match specific point names. This tool helps generate those patterns.</p>

                <h2>How to Use</h2>
                <ol class="help-steps">
                    <li><strong>Enter Point Names:</strong> Add the point names you want to match (one per line).</li>
                    <li><strong>Generate Pattern:</strong> Click "Generate Regex" to create a pattern that matches all entered names.</li>
                    <li><strong>Test Pattern:</strong> Verify the pattern matches what you expect.</li>
                    <li><strong>Copy Pattern:</strong> Use the generated regex in your Reflow configuration.</li>
                </ol>

                <h2>Pattern Types</h2>
                <h3>Exact Match</h3>
                <p>Matches only the specific point names entered:</p>
                <pre><code>^(SpaceTemp|DischargeAirTemp|ReturnAirTemp)$</code></pre>

                <h3>Contains Match</h3>
                <p>Matches any point containing these words:</p>
                <pre><code>(Temp|Status|Setpoint)</code></pre>

                <h3>Prefix/Suffix Match</h3>
                <p>Matches points starting or ending with specific text:</p>
                <pre><code>^(Occ|Unocc|Override).*</code></pre>
                <pre><code>.*(Status|Alarm|Fault)$</code></pre>

                <div class="help-warning-box">
                    <strong>⚠️ Regex Syntax:</strong>
                    Basic regex knowledge is helpful. Special characters like . * + ? need escaping with backslash if you want them literal.
                </div>

                <h2>Common Use Cases</h2>
                <ul>
                    <li>Match all schedule-related points</li>
                    <li>Find all status/alarm points</li>
                    <li>Select points for history extension</li>
                    <li>Batch-update point properties</li>
                </ul>
            `
        };

        function openHelpModal(section = 'station-tree') {
            document.getElementById('helpModal').style.display = 'flex';
            showHelpSection(section);
        }

        function closeHelpModal() {
            document.getElementById('helpModal').style.display = 'none';
        }

        function showHelpSection(sectionId) {
            // Update navigation active state
            document.querySelectorAll('.help-nav-item').forEach(item => {
                item.classList.remove('active');
            });
            event.target.classList.add('active');

            // Load content
            const content = helpContent[sectionId] || '<h1>Content Not Found</h1><p>This help section is under development.</p>';
            document.getElementById('helpContent').innerHTML = content;

            // Scroll content to top
            document.getElementById('helpContent').scrollTop = 0;
        }

        // Close help modal when clicking outside
        document.addEventListener('click', (e) => {
            if (e.target.id === 'helpModal') {
                closeHelpModal();
            }
        });

    </script>

    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <script>
        lucide.createIcons();
    </script>
</body>
</html>